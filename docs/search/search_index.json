{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Installing Midgard Midgard is available at PyPI . You can install it by simply running python -m pip install midgard Installing Midgard from source Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, etc. We recommend using the Anaconda distribution to ease the installation of these dependencies. Install Anaconda Go to www.anaconda.com/download , and download Anaconda for Python 3. Download the Midgard source code If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard Install dependencies You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard Install the Midgard package To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file Using Midgard Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Home"},{"location":"#midgard-the-python-geodesy-library","text":"Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting.","title":"Midgard, the Python Geodesy library"},{"location":"#installing-midgard","text":"Midgard is available at PyPI . You can install it by simply running python -m pip install midgard","title":"Installing Midgard"},{"location":"#installing-midgard-from-source","text":"Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, etc. We recommend using the Anaconda distribution to ease the installation of these dependencies.","title":"Installing Midgard from source"},{"location":"#install-anaconda","text":"Go to www.anaconda.com/download , and download Anaconda for Python 3.","title":"Install Anaconda"},{"location":"#download-the-midgard-source-code","text":"If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard","title":"Download the Midgard source code"},{"location":"#install-dependencies","text":"You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard","title":"Install dependencies"},{"location":"#install-the-midgard-package","text":"To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file","title":"Install the Midgard package"},{"location":"#using-midgard","text":"Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Using Midgard"},{"location":"api/midgard-collections/","text":"midgard.collections midgard.collections.enums Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. References: [1] RINEX Version 3.04 (2018): RINEX The receiver independent exchange format version 3.04, November 23, 2018 Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2 BeidouFreqNum2Freq Full name: midgard.collections.enums.BeidouFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. BeidouFrequency Full name: midgard.collections.enums.BeidouFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz ExitStatus Full name: midgard.collections.enums.ExitStatus Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition GPSFrequency Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz GalileoFreqNum2Freq Full name: midgard.collections.enums.GalileoFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. GalileoFrequency Full name: midgard.collections.enums.GalileoFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz GlonassFreqNum2Freq Full name: midgard.collections.enums.GlonassFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. Gnss3DigitIdToId Full name: midgard.collections.enums.Gnss3DigitIdToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier GnssIdTo3DigitId Full name: midgard.collections.enums.GnssIdTo3DigitId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier GnssIdToName Full name: midgard.collections.enums.GnssIdToName Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name GnssIdToReferenceSystem Full name: midgard.collections.enums.GnssIdToReferenceSystem Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name GnssNameToId Full name: midgard.collections.enums.GnssNameToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier GpsFreqNum2Freq Full name: midgard.collections.enums.GpsFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. IrnssFreqNum2Freq Full name: midgard.collections.enums.IrnssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. IrnssFrequency Full name: midgard.collections.enums.IrnssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz LogColor Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging LogLevel Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show NotGiven Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value QzssFreqNum2Freq Full name: midgard.collections.enums.QzssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. QzssFrequency Full name: midgard.collections.enums.QzssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz RefSysNameToEpsg Full name: midgard.collections.enums.RefSysNameToEpsg Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Reference system name to EPSG code SbasFreqNum2Freq Full name: midgard.collections.enums.SbasFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. SbasFrequency Full name: midgard.collections.enums.SbasFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz WriteLevel Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk enums () Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums. exit_status Full name: midgard.collections.enums.exit_status Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition get_enum () Full name: midgard.collections.enums.get_enum Signature: (name: str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name. get_value () Full name: midgard.collections.enums.get_value Signature: (name: str, value: str, default: Any = <class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name. gnss_3digit_id_to_id Full name: midgard.collections.enums.gnss_3digit_id_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier gnss_freq_C Full name: midgard.collections.enums.gnss_freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz gnss_freq_E Full name: midgard.collections.enums.gnss_freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz gnss_freq_G Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz gnss_freq_I Full name: midgard.collections.enums.gnss_freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz gnss_freq_J Full name: midgard.collections.enums.gnss_freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz gnss_freq_S Full name: midgard.collections.enums.gnss_freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz gnss_id_to_3digit_id Full name: midgard.collections.enums.gnss_id_to_3digit_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier gnss_id_to_name Full name: midgard.collections.enums.gnss_id_to_name Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name gnss_id_to_reference_system Full name: midgard.collections.enums.gnss_id_to_reference_system Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name gnss_name_to_id Full name: midgard.collections.enums.gnss_name_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier gnss_num2freq_C Full name: midgard.collections.enums.gnss_num2freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_E Full name: midgard.collections.enums.gnss_num2freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_G Full name: midgard.collections.enums.gnss_num2freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_I Full name: midgard.collections.enums.gnss_num2freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_J Full name: midgard.collections.enums.gnss_num2freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_R Full name: midgard.collections.enums.gnss_num2freq_R Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_S Full name: midgard.collections.enums.gnss_num2freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. has_value () Full name: midgard.collections.enums.has_value Signature: (name: str, value: str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise log_color Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging log_level Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show ref_sys_name_to_epsg Full name: midgard.collections.enums.ref_sys_name_to_epsg Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Reference system name to EPSG code register_enum () Full name: midgard.collections.enums.register_enum Signature: (name: str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration. write_level Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk midgard.collections.plate_motion_models Dataclass for handling tectonic plate motion models Description: You can add your own tectonic plate motion models via adding at the end of file: <model name> = PlateMotionModel( name: <model name> description: <model description> pole: <List with rotation pole definitions for different tectonics plate> ) Example: import numpy as np from midgard.collections import plate_motion_models Get list with available plate models models = plate_motion_models.models() Get PlateMotionModel instance for a given tectonic name model = plate_motion_models.get(\"itrf2014\") Get RotationPole object for Eurasian tectonic plate pole = model.get_pole(\"eura\", unit=\"radian per year\") Determine station velocity for given station position pos = np.array([2102928.189605, 721619.617278, 5958196.398820]) pole_vec = [pole.wx, pole.wy, pole.wz] vel = np.cross(pole_vec, pos) PlateMotionModel Full name: midgard.collections.plate_motion_models.PlateMotionModel Signature: (name: str, description: str, poles: Dict[str, object]) -> None Dataclass for plate motion model Attributes: name : Name of plate motion model description : Description of plate motion model poles : Dictionary with rotation pole definition for defined tectonic plates RotationPole Full name: midgard.collections.plate_motion_models.RotationPole Signature: (name: str, wx: float, wy: float, wz: float, dwx: float, dwy: float, dwz: float, unit: str, description: str) -> None Dataclass for plate motion model Attributes: name : Name of tectonic plate wx, wy, wx: Rotation pole (angular velocity) components dwx, dwy, dwz: Standard deviation of rotation pole components unit : Unit of rotation pole entries description : Description of tectonic plate get () Full name: midgard.collections.plate_motion_models.get Signature: (model: str) -> 'PlateMotionModel' Get a tectonic plate motion model by name Args: model : Plate motion model name Returns: Instance of PlateMotionModel dataclass itrf2008 (PlateMotionModel) itrf2008 = PlateMotionModel(name='itrf2008', description='ITRF2008 plate motion model', poles={'amur': RotationPole(name='amur', wx=-0.19, wy=-0.442, wz=0.915, dwx=0.04, dwy=0.051, dwz=0.049, unit='milliarcsecond per year', description='Amurian plate'), 'anta': RotationPole(name='anta', wx=-0.252, wy=-0.302, wz=0.643, dwx=0.008, dwy=0.006, dwz=0.009, unit='milliarcsecond per year', description='Antarctic plate'), 'arab': RotationPole(name='arab', wx=1.202, wy=-0.054, wz=1.485, dwx=0.082, dwy=0.1, dwz=0.063, unit='milliarcsecond per year', description='Arabian plate'), 'aust': RotationPole(name='aust', wx=1.504, wy=1.172, wz=1.228, dwx=0.007, dwy=0.007, dwz=0.007, unit='milliarcsecond per year', description='Australian plate'), 'carb': RotationPole(name='carb', wx=0.049, wy=-1.088, wz=0.664, dwx=0.201, dwy=0.417, dwz=0.146, unit='milliarcsecond per year', description='Caribbean plate'), 'eura': RotationPole(name='eura', wx=-0.083, wy=-0.534, wz=0.775, dwx=0.008, dwy=0.007, dwz=0.008, unit='milliarcsecond per year', description='Eurasian plate'), 'indi': RotationPole(name='indi', wx=1.232, wy=0.303, wz=1.54, dwx=0.031, dwy=0.128, dwz=0.03, unit='milliarcsecond per year', description='Indian plate'), 'nazc': RotationPole(name='nazc', wx=-0.333, wy=-1.551, wz=1.625, dwx=0.011, dwy=0.029, dwz=0.013, unit='milliarcsecond per year', description='Nazca plate'), 'noam': RotationPole(name='noam', wx=0.035, wy=-0.662, wz=-0.1, dwx=0.008, dwy=0.009, dwz=0.008, unit='milliarcsecond per year', description='North American plate'), 'nubi': RotationPole(name='nubi', wx=0.095, wy=-0.598, wz=0.723, dwx=0.009, dwy=0.007, dwz=0.009, unit='milliarcsecond per year', description='Nubia plate'), 'pcfc': RotationPole(name='pcfc', wx=-0.411, wy=1.036, wz=-2.166, dwx=0.007, dwy=0.007, dwz=0.009, unit='milliarcsecond per year', description='Pacific plate'), 'soam': RotationPole(name='soam', wx=-0.243, wy=-0.311, wz=-0.154, dwx=0.009, dwy=0.01, dwz=0.009, unit='milliarcsecond per year', description='South American plate'), 'soma': RotationPole(name='soma', wx=-0.08, wy=-0.745, wz=0.897, dwx=0.028, dwy=0.03, dwz=0.012, unit='milliarcsecond per year', description='Somali plate')}) itrf2014 (PlateMotionModel) itrf2014 = PlateMotionModel(name='itrf2014', description='ITRF2014 plate motion model', poles={'anta': RotationPole(name='anta', wx=-0.248, wy=-0.324, wz=0.675, dwx=0.004, dwy=0.004, dwz=0.008, unit='milliarcsecond per year', description='Antarctic plate'), 'arab': RotationPole(name='arab', wx=1.154, wy=-0.136, wz=1.444, dwx=0.02, dwy=0.022, dwz=0.014, unit='milliarcsecond per year', description='Arabian plate'), 'aust': RotationPole(name='aust', wx=1.51, wy=1.182, wz=1.215, dwx=0.004, dwy=0.004, dwz=0.004, unit='milliarcsecond per year', description='Australian plate'), 'eura': RotationPole(name='eura', wx=-0.085, wy=-0.531, wz=0.77, dwx=0.004, dwy=0.002, dwz=0.005, unit='milliarcsecond per year', description='Eurasian plate'), 'indi': RotationPole(name='indi', wx=1.154, wy=-0.005, wz=1.454, dwx=0.027, dwy=0.117, dwz=0.035, unit='milliarcsecond per year', description='Indian plate'), 'nazc': RotationPole(name='nazc', wx=-0.333, wy=-1.544, wz=1.623, dwx=0.006, dwy=0.015, dwz=0.007, unit='milliarcsecond per year', description='Nazca plate'), 'noam': RotationPole(name='noam', wx=0.024, wy=-0.694, wz=-0.063, dwx=0.002, dwy=0.005, dwz=0.004, unit='milliarcsecond per year', description='North American plate'), 'nubi': RotationPole(name='nubi', wx=0.099, wy=-0.614, wz=0.733, dwx=0.004, dwy=0.003, dwz=0.003, unit='milliarcsecond per year', description='Nubia plate'), 'pcfc': RotationPole(name='pcfc', wx=-0.409, wy=1.047, wz=-2.169, dwx=0.003, dwy=0.004, dwz=0.004, unit='milliarcsecond per year', description='Pacific plate'), 'soam': RotationPole(name='soam', wx=-0.27, wy=-0.301, wz=-0.14, dwx=0.006, dwy=0.006, dwz=0.003, unit='milliarcsecond per year', description='South American plate'), 'soma': RotationPole(name='soma', wx=-0.121, wy=-0.794, wz=0.884, dwx=0.035, dwy=0.034, dwz=0.008, unit='milliarcsecond per year', description='Somali plate')}) models () Full name: midgard.collections.plate_motion_models.models Signature: () -> List[str] Get a list of available tectonic plate motion models Returns: List of available tectonic plate motion models nnr_morvel56 (PlateMotionModel) nnr_morvel56 = PlateMotionModel(name='nnr_morvel56', description='NNR-MORVEL56 plate motion model', poles={'amur': RotationPole(name='amur', wx=-0.26156, wy=-0.40555, wz=0.9541, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Amurian plate'), 'anta': RotationPole(name='anta', wx=-0.17639, wy=-0.33021, wz=0.81844, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Antarctic plate'), 'arab': RotationPole(name='arab', wx=1.30893, wy=-0.19539, wz=1.51601, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Arabian plate'), 'aust': RotationPole(name='aust', wx=1.49003, wy=1.16163, wz=1.26766, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Australian plate'), 'capr': RotationPole(name='capr', wx=1.43757, wy=0.61288, wz=1.53251, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Capricorn plate'), 'carb': RotationPole(name='carb', wx=-0.03846, wy=-0.84045, wz=0.59349, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Caribbean plate'), 'coco': RotationPole(name='coco', wx=-2.16738, wy=-3.17607, wz=1.95327, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Cocos plate'), 'eura': RotationPole(name='eura', wx=-0.15004, wy=-0.50651, wz=0.6045, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Eurasian plate'), 'indi': RotationPole(name='indi', wx=1.24706, wy=-0.07169, wz=1.50832, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Indian plate'), 'juan': RotationPole(name='juan', wx=1.34157, wy=2.32742, wz=-2.12234, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Juan de Fuca plate'), 'lwan': RotationPole(name='lwan', wx=0.22233, wy=-0.59528, wz=0.81012, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Lwandle plate'), 'macq': RotationPole(name='macq', wx=2.64169, wy=0.51589, wz=3.11714, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Macquarie plate'), 'nazc': RotationPole(name='nazc', wx=-0.33251, wy=-1.70109, wz=1.80935, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Nazca plate'), 'noam': RotationPole(name='noam', wx=0.12193, wy=-0.73972, wz=-0.06361, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='North American plate'), 'nubi': RotationPole(name='nubi', wx=0.26008, wy=-0.65822, wz=0.77725, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Nubia plate'), 'pcfc': RotationPole(name='pcfc', wx=-0.43574, wy=0.94737, wz=-2.09883, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Pacific plate'), 'phil': RotationPole(name='phil', wx=1.94255, wy=-1.18388, wz=-2.35735, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Philippine Sea plate'), 'rive': RotationPole(name='rive', wx=-4.55332, wy=-14.62801, wz=5.65195, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Rivera plate'), 'sand': RotationPole(name='sand', wx=3.39908, wy=-2.54932, wz=-2.44715, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Sandwich plate'), 'scot': RotationPole(name='scot', wx=-0.13505, wy=-0.46636, wz=0.20131, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Scotia plate'), 'soam': RotationPole(name='soam', wx=0.07499, wy=-0.78168, wz=0.9342, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='South American plate'), 'soma': RotationPole(name='soma', wx=-0.14054, wy=-0.33384, wz=-0.15092, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Somali plate'), 'sund': RotationPole(name='sund', wx=-0.06815, wy=-0.77587, wz=0.93018, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Sunda plate'), 'sur_': RotationPole(name='sur_', wx=-0.11812, wy=-0.30264, wz=-0.20697, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Sur plate'), 'yang': RotationPole(name='ynag', wx=-0.24434, wy=-0.48751, wz=1.07163, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Yangtze plate')})","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollections","text":"","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollectionsenums","text":"Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. References: [1] RINEX Version 3.04 (2018): RINEX The receiver independent exchange format version 3.04, November 23, 2018 Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2","title":"midgard.collections.enums"},{"location":"api/midgard-collections/#beidoufreqnum2freq","text":"Full name: midgard.collections.enums.BeidouFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"BeidouFreqNum2Freq"},{"location":"api/midgard-collections/#beidoufrequency","text":"Full name: midgard.collections.enums.BeidouFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz","title":"BeidouFrequency"},{"location":"api/midgard-collections/#exitstatus","text":"Full name: midgard.collections.enums.ExitStatus Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition","title":"ExitStatus"},{"location":"api/midgard-collections/#gpsfrequency","text":"Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz","title":"GPSFrequency"},{"location":"api/midgard-collections/#galileofreqnum2freq","text":"Full name: midgard.collections.enums.GalileoFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"GalileoFreqNum2Freq"},{"location":"api/midgard-collections/#galileofrequency","text":"Full name: midgard.collections.enums.GalileoFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz","title":"GalileoFrequency"},{"location":"api/midgard-collections/#glonassfreqnum2freq","text":"Full name: midgard.collections.enums.GlonassFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"GlonassFreqNum2Freq"},{"location":"api/midgard-collections/#gnss3digitidtoid","text":"Full name: midgard.collections.enums.Gnss3DigitIdToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier","title":"Gnss3DigitIdToId"},{"location":"api/midgard-collections/#gnssidto3digitid","text":"Full name: midgard.collections.enums.GnssIdTo3DigitId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier","title":"GnssIdTo3DigitId"},{"location":"api/midgard-collections/#gnssidtoname","text":"Full name: midgard.collections.enums.GnssIdToName Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name","title":"GnssIdToName"},{"location":"api/midgard-collections/#gnssidtoreferencesystem","text":"Full name: midgard.collections.enums.GnssIdToReferenceSystem Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name","title":"GnssIdToReferenceSystem"},{"location":"api/midgard-collections/#gnssnametoid","text":"Full name: midgard.collections.enums.GnssNameToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier","title":"GnssNameToId"},{"location":"api/midgard-collections/#gpsfreqnum2freq","text":"Full name: midgard.collections.enums.GpsFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"GpsFreqNum2Freq"},{"location":"api/midgard-collections/#irnssfreqnum2freq","text":"Full name: midgard.collections.enums.IrnssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"IrnssFreqNum2Freq"},{"location":"api/midgard-collections/#irnssfrequency","text":"Full name: midgard.collections.enums.IrnssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz","title":"IrnssFrequency"},{"location":"api/midgard-collections/#logcolor","text":"Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"LogColor"},{"location":"api/midgard-collections/#loglevel","text":"Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"LogLevel"},{"location":"api/midgard-collections/#notgiven","text":"Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value","title":"NotGiven"},{"location":"api/midgard-collections/#qzssfreqnum2freq","text":"Full name: midgard.collections.enums.QzssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"QzssFreqNum2Freq"},{"location":"api/midgard-collections/#qzssfrequency","text":"Full name: midgard.collections.enums.QzssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz","title":"QzssFrequency"},{"location":"api/midgard-collections/#refsysnametoepsg","text":"Full name: midgard.collections.enums.RefSysNameToEpsg Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Reference system name to EPSG code","title":"RefSysNameToEpsg"},{"location":"api/midgard-collections/#sbasfreqnum2freq","text":"Full name: midgard.collections.enums.SbasFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"SbasFreqNum2Freq"},{"location":"api/midgard-collections/#sbasfrequency","text":"Full name: midgard.collections.enums.SbasFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz","title":"SbasFrequency"},{"location":"api/midgard-collections/#writelevel","text":"Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"WriteLevel"},{"location":"api/midgard-collections/#enums","text":"Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums.","title":"enums()"},{"location":"api/midgard-collections/#exit_status","text":"Full name: midgard.collections.enums.exit_status Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition","title":"exit_status"},{"location":"api/midgard-collections/#get_enum","text":"Full name: midgard.collections.enums.get_enum Signature: (name: str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name.","title":"get_enum()"},{"location":"api/midgard-collections/#get_value","text":"Full name: midgard.collections.enums.get_value Signature: (name: str, value: str, default: Any = <class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name.","title":"get_value()"},{"location":"api/midgard-collections/#gnss_3digit_id_to_id","text":"Full name: midgard.collections.enums.gnss_3digit_id_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier","title":"gnss_3digit_id_to_id"},{"location":"api/midgard-collections/#gnss_freq_c","text":"Full name: midgard.collections.enums.gnss_freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz","title":"gnss_freq_C"},{"location":"api/midgard-collections/#gnss_freq_e","text":"Full name: midgard.collections.enums.gnss_freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz","title":"gnss_freq_E"},{"location":"api/midgard-collections/#gnss_freq_g","text":"Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz","title":"gnss_freq_G"},{"location":"api/midgard-collections/#gnss_freq_i","text":"Full name: midgard.collections.enums.gnss_freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz","title":"gnss_freq_I"},{"location":"api/midgard-collections/#gnss_freq_j","text":"Full name: midgard.collections.enums.gnss_freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz","title":"gnss_freq_J"},{"location":"api/midgard-collections/#gnss_freq_s","text":"Full name: midgard.collections.enums.gnss_freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz","title":"gnss_freq_S"},{"location":"api/midgard-collections/#gnss_id_to_3digit_id","text":"Full name: midgard.collections.enums.gnss_id_to_3digit_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier","title":"gnss_id_to_3digit_id"},{"location":"api/midgard-collections/#gnss_id_to_name","text":"Full name: midgard.collections.enums.gnss_id_to_name Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name","title":"gnss_id_to_name"},{"location":"api/midgard-collections/#gnss_id_to_reference_system","text":"Full name: midgard.collections.enums.gnss_id_to_reference_system Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name","title":"gnss_id_to_reference_system"},{"location":"api/midgard-collections/#gnss_name_to_id","text":"Full name: midgard.collections.enums.gnss_name_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier","title":"gnss_name_to_id"},{"location":"api/midgard-collections/#gnss_num2freq_c","text":"Full name: midgard.collections.enums.gnss_num2freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_C"},{"location":"api/midgard-collections/#gnss_num2freq_e","text":"Full name: midgard.collections.enums.gnss_num2freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_E"},{"location":"api/midgard-collections/#gnss_num2freq_g","text":"Full name: midgard.collections.enums.gnss_num2freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_G"},{"location":"api/midgard-collections/#gnss_num2freq_i","text":"Full name: midgard.collections.enums.gnss_num2freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_I"},{"location":"api/midgard-collections/#gnss_num2freq_j","text":"Full name: midgard.collections.enums.gnss_num2freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_J"},{"location":"api/midgard-collections/#gnss_num2freq_r","text":"Full name: midgard.collections.enums.gnss_num2freq_R Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_R"},{"location":"api/midgard-collections/#gnss_num2freq_s","text":"Full name: midgard.collections.enums.gnss_num2freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_S"},{"location":"api/midgard-collections/#has_value","text":"Full name: midgard.collections.enums.has_value Signature: (name: str, value: str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise","title":"has_value()"},{"location":"api/midgard-collections/#log_color","text":"Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"log_color"},{"location":"api/midgard-collections/#log_level","text":"Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"log_level"},{"location":"api/midgard-collections/#ref_sys_name_to_epsg","text":"Full name: midgard.collections.enums.ref_sys_name_to_epsg Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Reference system name to EPSG code","title":"ref_sys_name_to_epsg"},{"location":"api/midgard-collections/#register_enum","text":"Full name: midgard.collections.enums.register_enum Signature: (name: str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration.","title":"register_enum()"},{"location":"api/midgard-collections/#write_level","text":"Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"write_level"},{"location":"api/midgard-collections/#midgardcollectionsplate_motion_models","text":"Dataclass for handling tectonic plate motion models Description: You can add your own tectonic plate motion models via adding at the end of file: <model name> = PlateMotionModel( name: <model name> description: <model description> pole: <List with rotation pole definitions for different tectonics plate> ) Example: import numpy as np from midgard.collections import plate_motion_models","title":"midgard.collections.plate_motion_models"},{"location":"api/midgard-collections/#get-list-with-available-plate-models","text":"models = plate_motion_models.models()","title":"Get list with available plate models"},{"location":"api/midgard-collections/#get-platemotionmodel-instance-for-a-given-tectonic-name","text":"model = plate_motion_models.get(\"itrf2014\")","title":"Get PlateMotionModel instance for a given tectonic name"},{"location":"api/midgard-collections/#get-rotationpole-object-for-eurasian-tectonic-plate","text":"pole = model.get_pole(\"eura\", unit=\"radian per year\")","title":"Get RotationPole object for Eurasian tectonic plate"},{"location":"api/midgard-collections/#determine-station-velocity-for-given-station-position","text":"pos = np.array([2102928.189605, 721619.617278, 5958196.398820]) pole_vec = [pole.wx, pole.wy, pole.wz] vel = np.cross(pole_vec, pos)","title":"Determine station velocity for given station position"},{"location":"api/midgard-collections/#platemotionmodel","text":"Full name: midgard.collections.plate_motion_models.PlateMotionModel Signature: (name: str, description: str, poles: Dict[str, object]) -> None Dataclass for plate motion model Attributes: name : Name of plate motion model description : Description of plate motion model poles : Dictionary with rotation pole definition for defined tectonic plates","title":"PlateMotionModel"},{"location":"api/midgard-collections/#rotationpole","text":"Full name: midgard.collections.plate_motion_models.RotationPole Signature: (name: str, wx: float, wy: float, wz: float, dwx: float, dwy: float, dwz: float, unit: str, description: str) -> None Dataclass for plate motion model Attributes: name : Name of tectonic plate wx, wy, wx: Rotation pole (angular velocity) components dwx, dwy, dwz: Standard deviation of rotation pole components unit : Unit of rotation pole entries description : Description of tectonic plate","title":"RotationPole"},{"location":"api/midgard-collections/#get","text":"Full name: midgard.collections.plate_motion_models.get Signature: (model: str) -> 'PlateMotionModel' Get a tectonic plate motion model by name Args: model : Plate motion model name Returns: Instance of PlateMotionModel dataclass","title":"get()"},{"location":"api/midgard-collections/#itrf2008-platemotionmodel","text":"itrf2008 = PlateMotionModel(name='itrf2008', description='ITRF2008 plate motion model', poles={'amur': RotationPole(name='amur', wx=-0.19, wy=-0.442, wz=0.915, dwx=0.04, dwy=0.051, dwz=0.049, unit='milliarcsecond per year', description='Amurian plate'), 'anta': RotationPole(name='anta', wx=-0.252, wy=-0.302, wz=0.643, dwx=0.008, dwy=0.006, dwz=0.009, unit='milliarcsecond per year', description='Antarctic plate'), 'arab': RotationPole(name='arab', wx=1.202, wy=-0.054, wz=1.485, dwx=0.082, dwy=0.1, dwz=0.063, unit='milliarcsecond per year', description='Arabian plate'), 'aust': RotationPole(name='aust', wx=1.504, wy=1.172, wz=1.228, dwx=0.007, dwy=0.007, dwz=0.007, unit='milliarcsecond per year', description='Australian plate'), 'carb': RotationPole(name='carb', wx=0.049, wy=-1.088, wz=0.664, dwx=0.201, dwy=0.417, dwz=0.146, unit='milliarcsecond per year', description='Caribbean plate'), 'eura': RotationPole(name='eura', wx=-0.083, wy=-0.534, wz=0.775, dwx=0.008, dwy=0.007, dwz=0.008, unit='milliarcsecond per year', description='Eurasian plate'), 'indi': RotationPole(name='indi', wx=1.232, wy=0.303, wz=1.54, dwx=0.031, dwy=0.128, dwz=0.03, unit='milliarcsecond per year', description='Indian plate'), 'nazc': RotationPole(name='nazc', wx=-0.333, wy=-1.551, wz=1.625, dwx=0.011, dwy=0.029, dwz=0.013, unit='milliarcsecond per year', description='Nazca plate'), 'noam': RotationPole(name='noam', wx=0.035, wy=-0.662, wz=-0.1, dwx=0.008, dwy=0.009, dwz=0.008, unit='milliarcsecond per year', description='North American plate'), 'nubi': RotationPole(name='nubi', wx=0.095, wy=-0.598, wz=0.723, dwx=0.009, dwy=0.007, dwz=0.009, unit='milliarcsecond per year', description='Nubia plate'), 'pcfc': RotationPole(name='pcfc', wx=-0.411, wy=1.036, wz=-2.166, dwx=0.007, dwy=0.007, dwz=0.009, unit='milliarcsecond per year', description='Pacific plate'), 'soam': RotationPole(name='soam', wx=-0.243, wy=-0.311, wz=-0.154, dwx=0.009, dwy=0.01, dwz=0.009, unit='milliarcsecond per year', description='South American plate'), 'soma': RotationPole(name='soma', wx=-0.08, wy=-0.745, wz=0.897, dwx=0.028, dwy=0.03, dwz=0.012, unit='milliarcsecond per year', description='Somali plate')})","title":"itrf2008 (PlateMotionModel)"},{"location":"api/midgard-collections/#itrf2014-platemotionmodel","text":"itrf2014 = PlateMotionModel(name='itrf2014', description='ITRF2014 plate motion model', poles={'anta': RotationPole(name='anta', wx=-0.248, wy=-0.324, wz=0.675, dwx=0.004, dwy=0.004, dwz=0.008, unit='milliarcsecond per year', description='Antarctic plate'), 'arab': RotationPole(name='arab', wx=1.154, wy=-0.136, wz=1.444, dwx=0.02, dwy=0.022, dwz=0.014, unit='milliarcsecond per year', description='Arabian plate'), 'aust': RotationPole(name='aust', wx=1.51, wy=1.182, wz=1.215, dwx=0.004, dwy=0.004, dwz=0.004, unit='milliarcsecond per year', description='Australian plate'), 'eura': RotationPole(name='eura', wx=-0.085, wy=-0.531, wz=0.77, dwx=0.004, dwy=0.002, dwz=0.005, unit='milliarcsecond per year', description='Eurasian plate'), 'indi': RotationPole(name='indi', wx=1.154, wy=-0.005, wz=1.454, dwx=0.027, dwy=0.117, dwz=0.035, unit='milliarcsecond per year', description='Indian plate'), 'nazc': RotationPole(name='nazc', wx=-0.333, wy=-1.544, wz=1.623, dwx=0.006, dwy=0.015, dwz=0.007, unit='milliarcsecond per year', description='Nazca plate'), 'noam': RotationPole(name='noam', wx=0.024, wy=-0.694, wz=-0.063, dwx=0.002, dwy=0.005, dwz=0.004, unit='milliarcsecond per year', description='North American plate'), 'nubi': RotationPole(name='nubi', wx=0.099, wy=-0.614, wz=0.733, dwx=0.004, dwy=0.003, dwz=0.003, unit='milliarcsecond per year', description='Nubia plate'), 'pcfc': RotationPole(name='pcfc', wx=-0.409, wy=1.047, wz=-2.169, dwx=0.003, dwy=0.004, dwz=0.004, unit='milliarcsecond per year', description='Pacific plate'), 'soam': RotationPole(name='soam', wx=-0.27, wy=-0.301, wz=-0.14, dwx=0.006, dwy=0.006, dwz=0.003, unit='milliarcsecond per year', description='South American plate'), 'soma': RotationPole(name='soma', wx=-0.121, wy=-0.794, wz=0.884, dwx=0.035, dwy=0.034, dwz=0.008, unit='milliarcsecond per year', description='Somali plate')})","title":"itrf2014 (PlateMotionModel)"},{"location":"api/midgard-collections/#models","text":"Full name: midgard.collections.plate_motion_models.models Signature: () -> List[str] Get a list of available tectonic plate motion models Returns: List of available tectonic plate motion models","title":"models()"},{"location":"api/midgard-collections/#nnr_morvel56-platemotionmodel","text":"nnr_morvel56 = PlateMotionModel(name='nnr_morvel56', description='NNR-MORVEL56 plate motion model', poles={'amur': RotationPole(name='amur', wx=-0.26156, wy=-0.40555, wz=0.9541, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Amurian plate'), 'anta': RotationPole(name='anta', wx=-0.17639, wy=-0.33021, wz=0.81844, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Antarctic plate'), 'arab': RotationPole(name='arab', wx=1.30893, wy=-0.19539, wz=1.51601, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Arabian plate'), 'aust': RotationPole(name='aust', wx=1.49003, wy=1.16163, wz=1.26766, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Australian plate'), 'capr': RotationPole(name='capr', wx=1.43757, wy=0.61288, wz=1.53251, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Capricorn plate'), 'carb': RotationPole(name='carb', wx=-0.03846, wy=-0.84045, wz=0.59349, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Caribbean plate'), 'coco': RotationPole(name='coco', wx=-2.16738, wy=-3.17607, wz=1.95327, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Cocos plate'), 'eura': RotationPole(name='eura', wx=-0.15004, wy=-0.50651, wz=0.6045, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Eurasian plate'), 'indi': RotationPole(name='indi', wx=1.24706, wy=-0.07169, wz=1.50832, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Indian plate'), 'juan': RotationPole(name='juan', wx=1.34157, wy=2.32742, wz=-2.12234, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Juan de Fuca plate'), 'lwan': RotationPole(name='lwan', wx=0.22233, wy=-0.59528, wz=0.81012, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Lwandle plate'), 'macq': RotationPole(name='macq', wx=2.64169, wy=0.51589, wz=3.11714, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Macquarie plate'), 'nazc': RotationPole(name='nazc', wx=-0.33251, wy=-1.70109, wz=1.80935, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Nazca plate'), 'noam': RotationPole(name='noam', wx=0.12193, wy=-0.73972, wz=-0.06361, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='North American plate'), 'nubi': RotationPole(name='nubi', wx=0.26008, wy=-0.65822, wz=0.77725, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Nubia plate'), 'pcfc': RotationPole(name='pcfc', wx=-0.43574, wy=0.94737, wz=-2.09883, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Pacific plate'), 'phil': RotationPole(name='phil', wx=1.94255, wy=-1.18388, wz=-2.35735, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Philippine Sea plate'), 'rive': RotationPole(name='rive', wx=-4.55332, wy=-14.62801, wz=5.65195, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Rivera plate'), 'sand': RotationPole(name='sand', wx=3.39908, wy=-2.54932, wz=-2.44715, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Sandwich plate'), 'scot': RotationPole(name='scot', wx=-0.13505, wy=-0.46636, wz=0.20131, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Scotia plate'), 'soam': RotationPole(name='soam', wx=0.07499, wy=-0.78168, wz=0.9342, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='South American plate'), 'soma': RotationPole(name='soma', wx=-0.14054, wy=-0.33384, wz=-0.15092, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Somali plate'), 'sund': RotationPole(name='sund', wx=-0.06815, wy=-0.77587, wz=0.93018, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Sunda plate'), 'sur_': RotationPole(name='sur_', wx=-0.11812, wy=-0.30264, wz=-0.20697, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Sur plate'), 'yang': RotationPole(name='ynag', wx=-0.24434, wy=-0.48751, wz=1.07163, dwx=nan, dwy=nan, dwz=nan, unit='milliarcsecond per year', description='Yangtze plate')})","title":"nnr_morvel56 (PlateMotionModel)"},{"location":"api/midgard-config/","text":"midgard.config midgard.config.config Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints: CasedConfigParser Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f173bbcaea0>, converters=<object object at 0x7f173bbcaea0>) ConfigParser with case-sensitive keys Configuration Full name: midgard.config.config.Configuration Signature: (name: str) -> None Represents a Configuration ConfigurationEntry Full name: midgard.config.config.ConfigurationEntry Signature: (key: str, value: Any, *, source: str = '', meta: Optional[Dict[str, str]] = None, vars_dict: Optional[Dict[str, str]] = None, _used_as: Optional[Set[str]] = None) -> None ConfigurationSection Full name: midgard.config.config.ConfigurationSection Signature: (name: str) -> None FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' midgard.config.files Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above. FileConfiguration Full name: midgard.config.files.FileConfiguration Signature: (name: str) -> None Configuration for handling files path_type (TypeVar) path_type = ~path_type","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfig","text":"","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfigconfig","text":"Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints:","title":"midgard.config.config"},{"location":"api/midgard-config/#casedconfigparser","text":"Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f173bbcaea0>, converters=<object object at 0x7f173bbcaea0>) ConfigParser with case-sensitive keys","title":"CasedConfigParser"},{"location":"api/midgard-config/#configuration","text":"Full name: midgard.config.config.Configuration Signature: (name: str) -> None Represents a Configuration","title":"Configuration"},{"location":"api/midgard-config/#configurationentry","text":"Full name: midgard.config.config.ConfigurationEntry Signature: (key: str, value: Any, *, source: str = '', meta: Optional[Dict[str, str]] = None, vars_dict: Optional[Dict[str, str]] = None, _used_as: Optional[Set[str]] = None) -> None","title":"ConfigurationEntry"},{"location":"api/midgard-config/#configurationsection","text":"Full name: midgard.config.config.ConfigurationSection Signature: (name: str) -> None","title":"ConfigurationSection"},{"location":"api/midgard-config/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-config/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-config/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-config/#midgardconfigfiles","text":"Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above.","title":"midgard.config.files"},{"location":"api/midgard-config/#fileconfiguration","text":"Full name: midgard.config.files.FileConfiguration Signature: (name: str) -> None Configuration for handling files","title":"FileConfiguration"},{"location":"api/midgard-config/#path_type-typevar","text":"path_type = ~path_type","title":"path_type (TypeVar)"},{"location":"api/midgard-data/","text":"midgard.data midgard.data._h5utils Simple utilities used by Dataset when dealing with HDF5 files decode_h5attr () Full name: midgard.data._h5utils.decode_h5attr Signature: (attr: Any) -> Any Convert hdf5 attribute back to its original datatype encode_h5attr () Full name: midgard.data._h5utils.encode_h5attr Signature: (data: Any) -> Any Convert a basic data type to something that can be saved as a hdf5 attribute Will raise a TypeError if the attribute cannot be saved in a way that allows reading and correct interpretation of the attribute. midgard.data._position Module for dealing with positions, velocities and position corrections in different coordinate systems PosBase Full name: midgard.data._position.PosBase Signature: () Base class for the various position and velocity arrays PosVelArray Full name: midgard.data._position.PosVelArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position and Velocity arrays This PosVelArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PosVelDeltaArray Full name: midgard.data._position.PosVelDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position and velocity deltas This PosVelDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. PositionArray Full name: midgard.data._position.PositionArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position arrays This PositionArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PositionDeltaArray Full name: midgard.data._position.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. VelocityArray Full name: midgard.data._position.VelocityArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray VelocityDeltaArray Full name: midgard.data._position.VelocityDeltaArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray register_attribute () Full name: midgard.data._position.register_attribute Signature: (cls: Callable, name: str) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: cls : Class to register the attribute for name : Name of attribute register_field () Full name: midgard.data._position.register_field Signature: (units: List[str], dependence: str = None) -> Callable Decorator used to register fields and their units Args: units: units for the field (tuple of strings) dependance: name of attribute that needs to be set for field to make sense register_system () Full name: midgard.data._position.register_system Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system. midgard.data._time Array with time epochs GpsTime Full name: midgard.data._time.GpsTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) GpsTimeDelta Full name: midgard.data._time.GpsTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TaiTime Full name: midgard.data._time.TaiTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TaiTimeDelta Full name: midgard.data._time.TaiTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TcgTime Full name: midgard.data._time.TcgTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TcgTimeDelta Full name: midgard.data._time.TcgTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TimeArray Full name: midgard.data._time.TimeArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time objects. Is immutable to allow the data to be hashable TimeBase Full name: midgard.data._time.TimeBase Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for TimeArray and TimeDeltaArray TimeDate Full name: midgard.data._time.TimeDate Signature: (val, val2=None, scale=None) TimeDateTime Full name: midgard.data._time.TimeDateTime Signature: (val, val2=None, scale=None) TimeDecimalYear Full name: midgard.data._time.TimeDecimalYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Variable year length. TimeDeltaArray Full name: midgard.data._time.TimeDeltaArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time delta objects. Is immutable to allow the data to be hashable TimeDeltaDateTime Full name: midgard.data._time.TimeDeltaDateTime Signature: (val, val2=None, scale=None) Time delta as datetime's timedelta TimeDeltaDay Full name: midgard.data._time.TimeDeltaDay Signature: (val, val2=None, scale=None) Time delta in days TimeDeltaFormat Full name: midgard.data._time.TimeDeltaFormat Signature: (val, val2=None, scale=None) Base class for Time Delta formats TimeDeltaJD Full name: midgard.data._time.TimeDeltaJD Signature: (val, val2=None, scale=None) Time delta as Julian days TimeDeltaSec Full name: midgard.data._time.TimeDeltaSec Signature: (val, val2=None, scale=None) Time delta in seconds TimeFormat Full name: midgard.data._time.TimeFormat Signature: (val, val2=None, scale=None) TimeGPSSec Full name: midgard.data._time.TimeGPSSec Signature: (val, val2=None, scale=None) Number of seconds since the GPS epoch 1980-01-06 00:00:00 UTC. TimeGPSWeekSec Full name: midgard.data._time.TimeGPSWeekSec Signature: (val, val2=None, scale=None) GPS weeks and seconds. TimeIso Full name: midgard.data._time.TimeIso Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DD HH:MM:SS.sss\u2026\u201d without the T TimeIsot Full name: midgard.data._time.TimeIsot Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DDTHH:MM:SS.sss\u2026\u201d TimeJD Full name: midgard.data._time.TimeJD Signature: (val, val2=None, scale=None) TimeJulianYear Full name: midgard.data._time.TimeJulianYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Fixed year length. TimeMJD Full name: midgard.data._time.TimeMJD Signature: (val, val2=None, scale=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000. TimeStr Full name: midgard.data._time.TimeStr Signature: (val, val2=None, scale=None) Base class for text based time. TimeYearDoy Full name: midgard.data._time.TimeYearDoy Signature: (val, val2=None, scale=None) TimeYyDddSssss Full name: midgard.data._time.TimeYyDddSssss Signature: (val, val2=None, scale=None) Time as 2 digit year, doy and second of day. Text based format \"yy:ddd:sssss\" yy - decimal year without century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format TimeYyyyDddSssss Full name: midgard.data._time.TimeYyyyDddSssss Signature: (val, val2=None, scale=None) Time as 4-digit year, doy and second of day. Text based format \"yyyy:ddd:sssss\" yyyy - decimal year with century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format TtTime Full name: midgard.data._time.TtTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TtTimeDelta Full name: midgard.data._time.TtTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) UtcTime Full name: midgard.data._time.UtcTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) UtcTimeDelta Full name: midgard.data._time.UtcTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) delta_gps_tai () Full name: midgard.data._time.delta_gps_tai Signature: (time: 'TimeArray') -> 'np_float' delta_tai_tt () Full name: midgard.data._time.delta_tai_tt Signature: (time: 'TimeArray') -> 'np_float' delta_tai_utc () Full name: midgard.data._time.delta_tai_utc Signature: (time: 'TimeArray') -> 'np_float' delta_tcg_tt () Full name: midgard.data._time.delta_tcg_tt Signature: (time: 'TimeArray') -> 'np_float' np_float (TypeVar) np_float = ~np_float read_tai_utc () Full name: midgard.data._time.read_tai_utc Signature: () register_format () Full name: midgard.data._time.register_format Signature: (cls: Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class. register_scale () Full name: midgard.data._time.register_scale Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale. midgard.data.collection A collection of fields Also serves as base class for dataset Collection Full name: midgard.data.collection.Collection Signature: () midgard.data.dataset A dataset for handling time series data Description: Dataset Full name: midgard.data.dataset.Dataset Signature: (num_obs: int = 0) -> None A dataset representing fields of data arrays Meta Full name: midgard.data.dataset.Meta Signature: (dict=None, /, **kwargs) field_type (str) field_type = 'time_delta' midgard.data.fieldtypes Field types that can be used by Dataset fieldtype () Full name: midgard.data.fieldtypes.fieldtype Signature: (data: Any) -> Callable Find correct field type for given data function () Full name: midgard.data.fieldtypes.function Signature: (plugin_name: str) -> Callable Function creating new field names () Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins midgard.data.fieldtypes._fieldtype Abstract class used to define different types of tables for a Dataset FieldType Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) Abstract class representing a type of field in the Dataset midgard.data.fieldtypes.bool A Dataset boolean field BoolField Full name: midgard.data.fieldtypes.bool.BoolField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.collection A Dataset collection field consisting of other fields CollectionField Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.float A Dataset float field FloatField Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.position A Dataset position field PositionField Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.position_delta A Dataset position delta field PositionDeltaField Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.posvel A Dataset position field PosVelField Full name: midgard.data.fieldtypes.posvel.PosVelField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.posvel_delta A Dataset position delta field PosVelDeltaField Full name: midgard.data.fieldtypes.posvel_delta.PosVelDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.sigma A Dataset sigma field SigmaField Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.text A Dataset text field TextField Full name: midgard.data.fieldtypes.text.TextField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.time A Dataset time field TimeField Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.time_delta A Dataset time field TimeDeltaField Full name: midgard.data.fieldtypes.time_delta.TimeDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.position Array with positions AcrPosVelDelta Full name: midgard.data.position.AcrPosVelDelta Signature: (val, ref_pos, **delta_args) AcrPositionDelta Full name: midgard.data.position.AcrPositionDelta Signature: (val, ref_pos, **delta_args) AcrVelocityDelta Full name: midgard.data.position.AcrVelocityDelta Signature: (val, ref_pos, **vel_args) EnuPosVelDelta Full name: midgard.data.position.EnuPosVelDelta Signature: (val, ref_pos, **delta_args) EnuPositionDelta Full name: midgard.data.position.EnuPositionDelta Signature: (val, ref_pos, **delta_args) EnuVelocityDelta Full name: midgard.data.position.EnuVelocityDelta Signature: (val, ref_pos, **vel_args) KeplerPosVel Full name: midgard.data.position.KeplerPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) LlhPosition Full name: midgard.data.position.LlhPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) PosVel () Full name: midgard.data.position.PosVel Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PosVelArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system. PosVelDelta () Full name: midgard.data.position.PosVelDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PosVelArray', **delta_args: Any) -> 'PosVelDeltaArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system. Position () Full name: midgard.data.position.Position Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. PositionDelta () Full name: midgard.data.position.PositionDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PositionArray', **delta_args: Any) -> 'PositionDeltaArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. TrsPosVel Full name: midgard.data.position.TrsPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) TrsPosVelDelta Full name: midgard.data.position.TrsPosVelDelta Signature: (val, ref_pos, **delta_args) TrsPosition Full name: midgard.data.position.TrsPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) TrsPositionDelta Full name: midgard.data.position.TrsPositionDelta Signature: (val, ref_pos, **delta_args) TrsVelocity Full name: midgard.data.position.TrsVelocity Signature: (val, ref_pos, **vel_args) TrsVelocityDelta Full name: midgard.data.position.TrsVelocityDelta Signature: (val, ref_pos, **vel_args) is_position () Full name: midgard.data.position.is_position Signature: (val) is_position_delta () Full name: midgard.data.position.is_position_delta Signature: (val) is_posvel () Full name: midgard.data.position.is_posvel Signature: (val) is_posvel_delta () Full name: midgard.data.position.is_posvel_delta Signature: (val) midgard.data.sigma Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma. SigmaArray Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None, unit=None) midgard.data.time Array with time epochs Time () Full name: midgard.data.time.Time Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Optional[numpy.ndarray] = None, _jd1: Optional[numpy.ndarray] = None, _jd2: Optional[numpy.ndarray] = None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format TimeDelta () Full name: midgard.data.time.TimeDelta Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Optional[numpy.ndarray] = None) -> 'TimeDeltaArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format is_time () Full name: midgard.data.time.is_time Signature: (val) is_timedelta () Full name: midgard.data.time.is_timedelta Signature: (val)","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata","text":"","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata_h5utils","text":"Simple utilities used by Dataset when dealing with HDF5 files","title":"midgard.data._h5utils"},{"location":"api/midgard-data/#decode_h5attr","text":"Full name: midgard.data._h5utils.decode_h5attr Signature: (attr: Any) -> Any Convert hdf5 attribute back to its original datatype","title":"decode_h5attr()"},{"location":"api/midgard-data/#encode_h5attr","text":"Full name: midgard.data._h5utils.encode_h5attr Signature: (data: Any) -> Any Convert a basic data type to something that can be saved as a hdf5 attribute Will raise a TypeError if the attribute cannot be saved in a way that allows reading and correct interpretation of the attribute.","title":"encode_h5attr()"},{"location":"api/midgard-data/#midgarddata_position","text":"Module for dealing with positions, velocities and position corrections in different coordinate systems","title":"midgard.data._position"},{"location":"api/midgard-data/#posbase","text":"Full name: midgard.data._position.PosBase Signature: () Base class for the various position and velocity arrays","title":"PosBase"},{"location":"api/midgard-data/#posvelarray","text":"Full name: midgard.data._position.PosVelArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position and Velocity arrays This PosVelArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PosVelArray"},{"location":"api/midgard-data/#posveldeltaarray","text":"Full name: midgard.data._position.PosVelDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position and velocity deltas This PosVelDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PosVelDeltaArray"},{"location":"api/midgard-data/#positionarray","text":"Full name: midgard.data._position.PositionArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position arrays This PositionArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PositionArray"},{"location":"api/midgard-data/#positiondeltaarray","text":"Full name: midgard.data._position.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PositionDeltaArray"},{"location":"api/midgard-data/#velocityarray","text":"Full name: midgard.data._position.VelocityArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray","title":"VelocityArray"},{"location":"api/midgard-data/#velocitydeltaarray","text":"Full name: midgard.data._position.VelocityDeltaArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray","title":"VelocityDeltaArray"},{"location":"api/midgard-data/#register_attribute","text":"Full name: midgard.data._position.register_attribute Signature: (cls: Callable, name: str) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: cls : Class to register the attribute for name : Name of attribute","title":"register_attribute()"},{"location":"api/midgard-data/#register_field","text":"Full name: midgard.data._position.register_field Signature: (units: List[str], dependence: str = None) -> Callable Decorator used to register fields and their units Args: units: units for the field (tuple of strings) dependance: name of attribute that needs to be set for field to make sense","title":"register_field()"},{"location":"api/midgard-data/#register_system","text":"Full name: midgard.data._position.register_system Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system.","title":"register_system()"},{"location":"api/midgard-data/#midgarddata_time","text":"Array with time epochs","title":"midgard.data._time"},{"location":"api/midgard-data/#gpstime","text":"Full name: midgard.data._time.GpsTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"GpsTime"},{"location":"api/midgard-data/#gpstimedelta","text":"Full name: midgard.data._time.GpsTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"GpsTimeDelta"},{"location":"api/midgard-data/#taitime","text":"Full name: midgard.data._time.TaiTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TaiTime"},{"location":"api/midgard-data/#taitimedelta","text":"Full name: midgard.data._time.TaiTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TaiTimeDelta"},{"location":"api/midgard-data/#tcgtime","text":"Full name: midgard.data._time.TcgTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TcgTime"},{"location":"api/midgard-data/#tcgtimedelta","text":"Full name: midgard.data._time.TcgTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TcgTimeDelta"},{"location":"api/midgard-data/#timearray","text":"Full name: midgard.data._time.TimeArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time objects. Is immutable to allow the data to be hashable","title":"TimeArray"},{"location":"api/midgard-data/#timebase","text":"Full name: midgard.data._time.TimeBase Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for TimeArray and TimeDeltaArray","title":"TimeBase"},{"location":"api/midgard-data/#timedate","text":"Full name: midgard.data._time.TimeDate Signature: (val, val2=None, scale=None)","title":"TimeDate"},{"location":"api/midgard-data/#timedatetime","text":"Full name: midgard.data._time.TimeDateTime Signature: (val, val2=None, scale=None)","title":"TimeDateTime"},{"location":"api/midgard-data/#timedecimalyear","text":"Full name: midgard.data._time.TimeDecimalYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Variable year length.","title":"TimeDecimalYear"},{"location":"api/midgard-data/#timedeltaarray","text":"Full name: midgard.data._time.TimeDeltaArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time delta objects. Is immutable to allow the data to be hashable","title":"TimeDeltaArray"},{"location":"api/midgard-data/#timedeltadatetime","text":"Full name: midgard.data._time.TimeDeltaDateTime Signature: (val, val2=None, scale=None) Time delta as datetime's timedelta","title":"TimeDeltaDateTime"},{"location":"api/midgard-data/#timedeltaday","text":"Full name: midgard.data._time.TimeDeltaDay Signature: (val, val2=None, scale=None) Time delta in days","title":"TimeDeltaDay"},{"location":"api/midgard-data/#timedeltaformat","text":"Full name: midgard.data._time.TimeDeltaFormat Signature: (val, val2=None, scale=None) Base class for Time Delta formats","title":"TimeDeltaFormat"},{"location":"api/midgard-data/#timedeltajd","text":"Full name: midgard.data._time.TimeDeltaJD Signature: (val, val2=None, scale=None) Time delta as Julian days","title":"TimeDeltaJD"},{"location":"api/midgard-data/#timedeltasec","text":"Full name: midgard.data._time.TimeDeltaSec Signature: (val, val2=None, scale=None) Time delta in seconds","title":"TimeDeltaSec"},{"location":"api/midgard-data/#timeformat","text":"Full name: midgard.data._time.TimeFormat Signature: (val, val2=None, scale=None)","title":"TimeFormat"},{"location":"api/midgard-data/#timegpssec","text":"Full name: midgard.data._time.TimeGPSSec Signature: (val, val2=None, scale=None) Number of seconds since the GPS epoch 1980-01-06 00:00:00 UTC.","title":"TimeGPSSec"},{"location":"api/midgard-data/#timegpsweeksec","text":"Full name: midgard.data._time.TimeGPSWeekSec Signature: (val, val2=None, scale=None) GPS weeks and seconds.","title":"TimeGPSWeekSec"},{"location":"api/midgard-data/#timeiso","text":"Full name: midgard.data._time.TimeIso Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DD HH:MM:SS.sss\u2026\u201d without the T","title":"TimeIso"},{"location":"api/midgard-data/#timeisot","text":"Full name: midgard.data._time.TimeIsot Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DDTHH:MM:SS.sss\u2026\u201d","title":"TimeIsot"},{"location":"api/midgard-data/#timejd","text":"Full name: midgard.data._time.TimeJD Signature: (val, val2=None, scale=None)","title":"TimeJD"},{"location":"api/midgard-data/#timejulianyear","text":"Full name: midgard.data._time.TimeJulianYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Fixed year length.","title":"TimeJulianYear"},{"location":"api/midgard-data/#timemjd","text":"Full name: midgard.data._time.TimeMJD Signature: (val, val2=None, scale=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000.","title":"TimeMJD"},{"location":"api/midgard-data/#timestr","text":"Full name: midgard.data._time.TimeStr Signature: (val, val2=None, scale=None) Base class for text based time.","title":"TimeStr"},{"location":"api/midgard-data/#timeyeardoy","text":"Full name: midgard.data._time.TimeYearDoy Signature: (val, val2=None, scale=None)","title":"TimeYearDoy"},{"location":"api/midgard-data/#timeyydddsssss","text":"Full name: midgard.data._time.TimeYyDddSssss Signature: (val, val2=None, scale=None) Time as 2 digit year, doy and second of day. Text based format \"yy:ddd:sssss\" yy - decimal year without century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format","title":"TimeYyDddSssss"},{"location":"api/midgard-data/#timeyyyydddsssss","text":"Full name: midgard.data._time.TimeYyyyDddSssss Signature: (val, val2=None, scale=None) Time as 4-digit year, doy and second of day. Text based format \"yyyy:ddd:sssss\" yyyy - decimal year with century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format","title":"TimeYyyyDddSssss"},{"location":"api/midgard-data/#tttime","text":"Full name: midgard.data._time.TtTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TtTime"},{"location":"api/midgard-data/#tttimedelta","text":"Full name: midgard.data._time.TtTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TtTimeDelta"},{"location":"api/midgard-data/#utctime","text":"Full name: midgard.data._time.UtcTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"UtcTime"},{"location":"api/midgard-data/#utctimedelta","text":"Full name: midgard.data._time.UtcTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"UtcTimeDelta"},{"location":"api/midgard-data/#delta_gps_tai","text":"Full name: midgard.data._time.delta_gps_tai Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_gps_tai()"},{"location":"api/midgard-data/#delta_tai_tt","text":"Full name: midgard.data._time.delta_tai_tt Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_tai_tt()"},{"location":"api/midgard-data/#delta_tai_utc","text":"Full name: midgard.data._time.delta_tai_utc Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_tai_utc()"},{"location":"api/midgard-data/#delta_tcg_tt","text":"Full name: midgard.data._time.delta_tcg_tt Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_tcg_tt()"},{"location":"api/midgard-data/#np_float-typevar","text":"np_float = ~np_float","title":"np_float (TypeVar)"},{"location":"api/midgard-data/#read_tai_utc","text":"Full name: midgard.data._time.read_tai_utc Signature: ()","title":"read_tai_utc()"},{"location":"api/midgard-data/#register_format","text":"Full name: midgard.data._time.register_format Signature: (cls: Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class.","title":"register_format()"},{"location":"api/midgard-data/#register_scale","text":"Full name: midgard.data._time.register_scale Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale.","title":"register_scale()"},{"location":"api/midgard-data/#midgarddatacollection","text":"A collection of fields Also serves as base class for dataset","title":"midgard.data.collection"},{"location":"api/midgard-data/#collection","text":"Full name: midgard.data.collection.Collection Signature: ()","title":"Collection"},{"location":"api/midgard-data/#midgarddatadataset","text":"A dataset for handling time series data Description:","title":"midgard.data.dataset"},{"location":"api/midgard-data/#dataset","text":"Full name: midgard.data.dataset.Dataset Signature: (num_obs: int = 0) -> None A dataset representing fields of data arrays","title":"Dataset"},{"location":"api/midgard-data/#meta","text":"Full name: midgard.data.dataset.Meta Signature: (dict=None, /, **kwargs)","title":"Meta"},{"location":"api/midgard-data/#field_type-str","text":"field_type = 'time_delta'","title":"field_type (str)"},{"location":"api/midgard-data/#midgarddatafieldtypes","text":"Field types that can be used by Dataset","title":"midgard.data.fieldtypes"},{"location":"api/midgard-data/#fieldtype","text":"Full name: midgard.data.fieldtypes.fieldtype Signature: (data: Any) -> Callable Find correct field type for given data","title":"fieldtype()"},{"location":"api/midgard-data/#function","text":"Full name: midgard.data.fieldtypes.function Signature: (plugin_name: str) -> Callable Function creating new field","title":"function()"},{"location":"api/midgard-data/#names","text":"Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins","title":"names()"},{"location":"api/midgard-data/#midgarddatafieldtypes_fieldtype","text":"Abstract class used to define different types of tables for a Dataset","title":"midgard.data.fieldtypes._fieldtype"},{"location":"api/midgard-data/#fieldtype_1","text":"Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) Abstract class representing a type of field in the Dataset","title":"FieldType"},{"location":"api/midgard-data/#midgarddatafieldtypesbool","text":"A Dataset boolean field","title":"midgard.data.fieldtypes.bool"},{"location":"api/midgard-data/#boolfield","text":"Full name: midgard.data.fieldtypes.bool.BoolField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"BoolField"},{"location":"api/midgard-data/#midgarddatafieldtypescollection","text":"A Dataset collection field consisting of other fields","title":"midgard.data.fieldtypes.collection"},{"location":"api/midgard-data/#collectionfield","text":"Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"CollectionField"},{"location":"api/midgard-data/#midgarddatafieldtypesfloat","text":"A Dataset float field","title":"midgard.data.fieldtypes.float"},{"location":"api/midgard-data/#floatfield","text":"Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"FloatField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition","text":"A Dataset position field","title":"midgard.data.fieldtypes.position"},{"location":"api/midgard-data/#positionfield","text":"Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PositionField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.position_delta"},{"location":"api/midgard-data/#positiondeltafield","text":"Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PositionDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypesposvel","text":"A Dataset position field","title":"midgard.data.fieldtypes.posvel"},{"location":"api/midgard-data/#posvelfield","text":"Full name: midgard.data.fieldtypes.posvel.PosVelField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PosVelField"},{"location":"api/midgard-data/#midgarddatafieldtypesposvel_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.posvel_delta"},{"location":"api/midgard-data/#posveldeltafield","text":"Full name: midgard.data.fieldtypes.posvel_delta.PosVelDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PosVelDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypessigma","text":"A Dataset sigma field","title":"midgard.data.fieldtypes.sigma"},{"location":"api/midgard-data/#sigmafield","text":"Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"SigmaField"},{"location":"api/midgard-data/#midgarddatafieldtypestext","text":"A Dataset text field","title":"midgard.data.fieldtypes.text"},{"location":"api/midgard-data/#textfield","text":"Full name: midgard.data.fieldtypes.text.TextField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"TextField"},{"location":"api/midgard-data/#midgarddatafieldtypestime","text":"A Dataset time field","title":"midgard.data.fieldtypes.time"},{"location":"api/midgard-data/#timefield","text":"Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"TimeField"},{"location":"api/midgard-data/#midgarddatafieldtypestime_delta","text":"A Dataset time field","title":"midgard.data.fieldtypes.time_delta"},{"location":"api/midgard-data/#timedeltafield","text":"Full name: midgard.data.fieldtypes.time_delta.TimeDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"TimeDeltaField"},{"location":"api/midgard-data/#midgarddataposition","text":"Array with positions","title":"midgard.data.position"},{"location":"api/midgard-data/#acrposveldelta","text":"Full name: midgard.data.position.AcrPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"AcrPosVelDelta"},{"location":"api/midgard-data/#acrpositiondelta","text":"Full name: midgard.data.position.AcrPositionDelta Signature: (val, ref_pos, **delta_args)","title":"AcrPositionDelta"},{"location":"api/midgard-data/#acrvelocitydelta","text":"Full name: midgard.data.position.AcrVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"AcrVelocityDelta"},{"location":"api/midgard-data/#enuposveldelta","text":"Full name: midgard.data.position.EnuPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPosVelDelta"},{"location":"api/midgard-data/#enupositiondelta","text":"Full name: midgard.data.position.EnuPositionDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPositionDelta"},{"location":"api/midgard-data/#enuvelocitydelta","text":"Full name: midgard.data.position.EnuVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"EnuVelocityDelta"},{"location":"api/midgard-data/#keplerposvel","text":"Full name: midgard.data.position.KeplerPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"KeplerPosVel"},{"location":"api/midgard-data/#llhposition","text":"Full name: midgard.data.position.LlhPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"LlhPosition"},{"location":"api/midgard-data/#posvel","text":"Full name: midgard.data.position.PosVel Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PosVelArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system.","title":"PosVel()"},{"location":"api/midgard-data/#posveldelta","text":"Full name: midgard.data.position.PosVelDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PosVelArray', **delta_args: Any) -> 'PosVelDeltaArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system.","title":"PosVelDelta()"},{"location":"api/midgard-data/#position","text":"Full name: midgard.data.position.Position Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"Position()"},{"location":"api/midgard-data/#positiondelta","text":"Full name: midgard.data.position.PositionDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PositionArray', **delta_args: Any) -> 'PositionDeltaArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"PositionDelta()"},{"location":"api/midgard-data/#trsposvel","text":"Full name: midgard.data.position.TrsPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"TrsPosVel"},{"location":"api/midgard-data/#trsposveldelta","text":"Full name: midgard.data.position.TrsPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPosVelDelta"},{"location":"api/midgard-data/#trsposition","text":"Full name: midgard.data.position.TrsPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"TrsPosition"},{"location":"api/midgard-data/#trspositiondelta","text":"Full name: midgard.data.position.TrsPositionDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPositionDelta"},{"location":"api/midgard-data/#trsvelocity","text":"Full name: midgard.data.position.TrsVelocity Signature: (val, ref_pos, **vel_args)","title":"TrsVelocity"},{"location":"api/midgard-data/#trsvelocitydelta","text":"Full name: midgard.data.position.TrsVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"TrsVelocityDelta"},{"location":"api/midgard-data/#is_position","text":"Full name: midgard.data.position.is_position Signature: (val)","title":"is_position()"},{"location":"api/midgard-data/#is_position_delta","text":"Full name: midgard.data.position.is_position_delta Signature: (val)","title":"is_position_delta()"},{"location":"api/midgard-data/#is_posvel","text":"Full name: midgard.data.position.is_posvel Signature: (val)","title":"is_posvel()"},{"location":"api/midgard-data/#is_posvel_delta","text":"Full name: midgard.data.position.is_posvel_delta Signature: (val)","title":"is_posvel_delta()"},{"location":"api/midgard-data/#midgarddatasigma","text":"Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma.","title":"midgard.data.sigma"},{"location":"api/midgard-data/#sigmaarray","text":"Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None, unit=None)","title":"SigmaArray"},{"location":"api/midgard-data/#midgarddatatime","text":"Array with time epochs","title":"midgard.data.time"},{"location":"api/midgard-data/#time","text":"Full name: midgard.data.time.Time Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Optional[numpy.ndarray] = None, _jd1: Optional[numpy.ndarray] = None, _jd2: Optional[numpy.ndarray] = None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"Time()"},{"location":"api/midgard-data/#timedelta","text":"Full name: midgard.data.time.TimeDelta Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Optional[numpy.ndarray] = None) -> 'TimeDeltaArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"TimeDelta()"},{"location":"api/midgard-data/#is_time","text":"Full name: midgard.data.time.is_time Signature: (val)","title":"is_time()"},{"location":"api/midgard-data/#is_timedelta","text":"Full name: midgard.data.time.is_timedelta Signature: (val)","title":"is_timedelta()"},{"location":"api/midgard-dev/","text":"midgard.dev midgard.dev.console Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background! columns () Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters. dedent () Full name: midgard.dev.console.dedent Signature: (text: str, num_spaces: Optional[int] = None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string. fill () Full name: midgard.dev.console.fill Signature: (text: str, *, width: Optional[int] = None, hanging: Optional[int] = None, **tw_args: Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string. indent () Full name: midgard.dev.console.indent Signature: (text: str, num_spaces: int, **tw_args: Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string. lines () Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters. num_leading_spaces () Full name: midgard.dev.console.num_leading_spaces Signature: (text: str, space_char: str = ' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces. progress_bar () Full name: midgard.dev.console.progress_bar Signature: (iteration: int, total: int, prefix: str = '') Call in a loop to create terminal progress bar Args: iteration current iteration total total iterations prefix prefix string midgard.dev.exceptions Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling. FieldDoesNotExistError Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: () FieldExistsError Full name: midgard.dev.exceptions.FieldExistsError Signature: () InitializationError Full name: midgard.dev.exceptions.InitializationError Signature: () MidgardException Full name: midgard.dev.exceptions.MidgardException Signature: () MidgardExit Full name: midgard.dev.exceptions.MidgardExit Signature: () MissingConfigurationError Full name: midgard.dev.exceptions.MissingConfigurationError Signature: () MissingDataError Full name: midgard.dev.exceptions.MissingDataError Signature: () MissingEntryError Full name: midgard.dev.exceptions.MissingEntryError Signature: () MissingSectionError Full name: midgard.dev.exceptions.MissingSectionError Signature: () ParserError Full name: midgard.dev.exceptions.ParserError Signature: () TimerNotRunning Full name: midgard.dev.exceptions.TimerNotRunning Signature: () TimerRunning Full name: midgard.dev.exceptions.TimerRunning Signature: () UnitError Full name: midgard.dev.exceptions.UnitError Signature: () UnknownConstantError Full name: midgard.dev.exceptions.UnknownConstantError Signature: () UnknownConversionError Full name: midgard.dev.exceptions.UnknownConversionError Signature: () UnknownEnumError Full name: midgard.dev.exceptions.UnknownEnumError Signature: () UnknownPackageError Full name: midgard.dev.exceptions.UnknownPackageError Signature: () UnknownPluginError Full name: midgard.dev.exceptions.UnknownPluginError Signature: () UnknownSystemError Full name: midgard.dev.exceptions.UnknownSystemError Signature: () midgard.dev.library Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them. SimpleMock Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). load_name () Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library. load_path () Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library. midgard.dev.log Midgard library module for logging Description: The Midgard log module provides simple logging functionality. To use it, you must first add a an active logger. This is typically done using the init-functions: init() and/or file_init() . init() initializes a console logger, where logging messages are written to the console. file_init() initializes a file logger, where logging messages are written to a defined file path. Following logging levels are defined: Level Description debug Debug messages info Information messages warn Warning messages error Error messages fatal Fatal error messages To write a log message, simply call log.{level} (e.g. log.info), whereby {level} is a placeholder for the defined logging levels in the table above. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix ConsoleLogger Full name: midgard.dev.log.ConsoleLogger Signature: (log_level: Optional[str] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters FileLogger Full name: midgard.dev.log.FileLogger Signature: (file_path: Union[str, pathlib.Path], log_level: Optional[str] = None, prefix: str = '', rotation: Optional[int] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones. Logger Full name: midgard.dev.log.Logger Signature: (log_level: Optional[str] = None, prefix: str = '') Abstract class that can be specialized to create new loggers blank () Full name: midgard.dev.log.blank Signature: () -> None Log blank line file_init Full name: midgard.dev.log.file_init Signature: (file_path: Union[str, pathlib.Path], log_level: Optional[str] = None, prefix: str = '', rotation: Optional[int] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones. init Full name: midgard.dev.log.init Signature: (log_level: Optional[str] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters log () Full name: midgard.dev.log.log Signature: (log_text: str, level: str) -> None Log text at the given level print_file () Full name: midgard.dev.log.print_file Signature: (log_path: Union[str, pathlib.Path], log_level: str = 'info', print_func: Callable[[str], NoneType] = <built-in function print>) -> None Print a log file with colors, stripping away any item below log_level midgard.dev.plugins Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(*args, **kwargs): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...) Plugin Full name: midgard.dev.plugins.Plugin Signature: (name: str, function: Callable, file_path: pathlib.Path, sort_value: int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called. add_alias () Full name: midgard.dev.plugins.add_alias Signature: (package_name: str, alias: str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory. call () Full name: midgard.dev.plugins.call Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None, plugin_logger: Optional[Callable[[str], NoneType]] = None, **plugin_args: Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in. call_all () Full name: midgard.dev.plugins.call_all Signature: (package_name: str, plugins: Optional[List[str]] = None, part: Optional[str] = None, prefix: Optional[str] = None, plugin_logger: Optional[Callable[[str], NoneType]] = None, **plugin_args: Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins. doc () Full name: midgard.dev.plugins.doc Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in. doc_all () Full name: midgard.dev.plugins.doc_all Signature: (package_name: str, plugins: Optional[Iterable[str]] = None, prefix: Optional[str] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins. exists () Full name: midgard.dev.plugins.exists Signature: (package_name: str, plugin_name: str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise. get () Full name: midgard.dev.plugins.get Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in. load () Full name: midgard.dev.plugins.load Signature: (package_name: str, plugin_name: str, prefix: Optional[str] = None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix). names () Full name: midgard.dev.plugins.names Signature: (package_name: str, plugins: Optional[Iterable[str]] = None, prefix: Optional[str] = None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins. parts () Full name: midgard.dev.plugins.parts Signature: (package_name: str, plugin_name: str, prefix: Optional[str] = None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts. register () Full name: midgard.dev.plugins.register Signature: (func: Callable, name: Optional[str] = None, sort_value: int = 0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files. Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered. register_named () Full name: midgard.dev.plugins.register_named Signature: (name: str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function. register_ordered () Full name: midgard.dev.plugins.register_ordered Signature: (sort_value: int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function. signature () Full name: midgard.dev.plugins.signature Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin midgard.dev.profiler Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler. CProfile Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program LineProfiler Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail Profiler Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers midgard.dev.timer Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details. AccumulatedTimer Full name: midgard.dev.timer.AccumulatedTimer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Optional[Callable[[str], NoneType]] = functools.partial(<function log at 0x7f174b56be20>, level='info')) -> None Timer Full name: midgard.dev.timer.Timer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Optional[Callable[[str], NoneType]] = functools.partial(<function log at 0x7f174b56be20>, level='info')) -> None Class for timing running time of functions and code blocks. midgard.dev.util Midgard library module with utility functions for easier script development Example: from midgard.dev import util directory, date = util.parse_args('string', 'date') Description: This module provides the boilerplate code necessary for starting a script. In particular handling of command line arguments and default options including --help are done. COMMAND (str) COMMAND = 'generate_api ' check_help_and_version () Full name: midgard.dev.util.check_help_and_version Signature: (module: str, doc_module: str = None, replace_vars: Dict[str, str] = {}) -> None Show help or version if asked for Show the help message parsed from the script's docstring if -h or --help option is given. Show the script's version if --version is given. Args: module : Module name. doc_module : Module containing help text. replace_vars : Dictionary with variable for replacement in docstring check_options () Full name: midgard.dev.util.check_options Signature: (*options: Tuple[str]) -> str Check if any of a list of options is specified on the command line Returns the actual option that is specified. The first option specified on the command line is returned if there are several matches. Returns the empty string if no option is specified. This means that this method works fine also in a boolean context, for example if check_options('-F', '--force'): do_something() Args: options : Strings specifying which options to check for, including '-'-prefix. Returns: String : Option that is specified, blank string if no option is specified get_callers () Full name: midgard.dev.util.get_callers Signature: () -> str Get a list of methods calling this function Returns: Lists all methods calling the function get_pid_and_server () Full name: midgard.dev.util.get_pid_and_server Signature: () -> str Find process id and name of server the analysis is running on Use the platform.uname to find servername instead of os.uname because the latter is not supported on Windows. Returns: Process id and name of server get_program_info () Full name: midgard.dev.util.get_program_info Signature: (module: str) -> str Get the name and the version of the running program Args: module : Module name. Returns: Program name and version get_program_name () Full name: midgard.dev.util.get_program_name Signature: () -> str Get the name of the running program Returns: String trying to be similar to how the user called the program. get_python_version () Full name: midgard.dev.util.get_python_version Signature: () -> str Find python version used Returns: Name of executable and version number no_traceback () Full name: midgard.dev.util.no_traceback Signature: (func) Decorator for turning off traceback, instead printing a simple error message Use the option --show_tb to show the traceback anyway. not_implemented () Full name: midgard.dev.util.not_implemented Signature: () -> None A placeholder for functions that are not implemented yet A note about the missing implementation is written to the log. options2args () Full name: midgard.dev.util.options2args Signature: (options: List[str]) -> Union[List[str], Dict[str, str]] Convert a list of command line options to a args and kwargs The options should be specified as a string with the necessary - or -- in front and options with a value should by separated by = (e.g. --station=stas). Args: options : List with options Returns: Tuple with non-keyword arguments and with keyword arguments parse_args () Full name: midgard.dev.util.parse_args Signature: (*param_types: Tuple[str], doc_module: str = None) -> Union[Any, List[Any]] Parse command line arguments and general options Parse arguments from the given parameter types. Args: param_types : Strings describing the expected parameter types. Each string must be one of the keys in #_PARSERS. doc_module : Module containing help text. Returns: List of command line arguments parsed according to param_types. read_option_value () Full name: midgard.dev.util.read_option_value Signature: (option: str, default: str = '') -> str Read the value of one command line option The option should be specified as a string with the necessary - or -- in front. If that option is not one of the command line arguments, default is returned. If there is a value following the option that value is returned as a string (separated by =). If there are several occurences of the option, the first one is returned. Args: option : Option specified with the leading - or --. default : Optional default value that is returned if the option is not specified. Returns: The option or the value of the option. The default value if the option is not specified. write_requirements () Full name: midgard.dev.util.write_requirements Signature: (file_path: Union[str, pathlib.Path]) -> None Write requirements (python modules) to file for reproducibility. Note that this only stores the modules that have been imported, and that have a __version__ -attribute (see PEP 396 - https://www.python.org/dev/peps/pep-0396/) Args: file_path : File path.","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddev","text":"","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddevconsole","text":"Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background!","title":"midgard.dev.console"},{"location":"api/midgard-dev/#columns","text":"Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters.","title":"columns()"},{"location":"api/midgard-dev/#dedent","text":"Full name: midgard.dev.console.dedent Signature: (text: str, num_spaces: Optional[int] = None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string.","title":"dedent()"},{"location":"api/midgard-dev/#fill","text":"Full name: midgard.dev.console.fill Signature: (text: str, *, width: Optional[int] = None, hanging: Optional[int] = None, **tw_args: Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string.","title":"fill()"},{"location":"api/midgard-dev/#indent","text":"Full name: midgard.dev.console.indent Signature: (text: str, num_spaces: int, **tw_args: Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string.","title":"indent()"},{"location":"api/midgard-dev/#lines","text":"Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters.","title":"lines()"},{"location":"api/midgard-dev/#num_leading_spaces","text":"Full name: midgard.dev.console.num_leading_spaces Signature: (text: str, space_char: str = ' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces.","title":"num_leading_spaces()"},{"location":"api/midgard-dev/#progress_bar","text":"Full name: midgard.dev.console.progress_bar Signature: (iteration: int, total: int, prefix: str = '') Call in a loop to create terminal progress bar Args: iteration current iteration total total iterations prefix prefix string","title":"progress_bar()"},{"location":"api/midgard-dev/#midgarddevexceptions","text":"Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling.","title":"midgard.dev.exceptions"},{"location":"api/midgard-dev/#fielddoesnotexisterror","text":"Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: ()","title":"FieldDoesNotExistError"},{"location":"api/midgard-dev/#fieldexistserror","text":"Full name: midgard.dev.exceptions.FieldExistsError Signature: ()","title":"FieldExistsError"},{"location":"api/midgard-dev/#initializationerror","text":"Full name: midgard.dev.exceptions.InitializationError Signature: ()","title":"InitializationError"},{"location":"api/midgard-dev/#midgardexception","text":"Full name: midgard.dev.exceptions.MidgardException Signature: ()","title":"MidgardException"},{"location":"api/midgard-dev/#midgardexit","text":"Full name: midgard.dev.exceptions.MidgardExit Signature: ()","title":"MidgardExit"},{"location":"api/midgard-dev/#missingconfigurationerror","text":"Full name: midgard.dev.exceptions.MissingConfigurationError Signature: ()","title":"MissingConfigurationError"},{"location":"api/midgard-dev/#missingdataerror","text":"Full name: midgard.dev.exceptions.MissingDataError Signature: ()","title":"MissingDataError"},{"location":"api/midgard-dev/#missingentryerror","text":"Full name: midgard.dev.exceptions.MissingEntryError Signature: ()","title":"MissingEntryError"},{"location":"api/midgard-dev/#missingsectionerror","text":"Full name: midgard.dev.exceptions.MissingSectionError Signature: ()","title":"MissingSectionError"},{"location":"api/midgard-dev/#parsererror","text":"Full name: midgard.dev.exceptions.ParserError Signature: ()","title":"ParserError"},{"location":"api/midgard-dev/#timernotrunning","text":"Full name: midgard.dev.exceptions.TimerNotRunning Signature: ()","title":"TimerNotRunning"},{"location":"api/midgard-dev/#timerrunning","text":"Full name: midgard.dev.exceptions.TimerRunning Signature: ()","title":"TimerRunning"},{"location":"api/midgard-dev/#uniterror","text":"Full name: midgard.dev.exceptions.UnitError Signature: ()","title":"UnitError"},{"location":"api/midgard-dev/#unknownconstanterror","text":"Full name: midgard.dev.exceptions.UnknownConstantError Signature: ()","title":"UnknownConstantError"},{"location":"api/midgard-dev/#unknownconversionerror","text":"Full name: midgard.dev.exceptions.UnknownConversionError Signature: ()","title":"UnknownConversionError"},{"location":"api/midgard-dev/#unknownenumerror","text":"Full name: midgard.dev.exceptions.UnknownEnumError Signature: ()","title":"UnknownEnumError"},{"location":"api/midgard-dev/#unknownpackageerror","text":"Full name: midgard.dev.exceptions.UnknownPackageError Signature: ()","title":"UnknownPackageError"},{"location":"api/midgard-dev/#unknownpluginerror","text":"Full name: midgard.dev.exceptions.UnknownPluginError Signature: ()","title":"UnknownPluginError"},{"location":"api/midgard-dev/#unknownsystemerror","text":"Full name: midgard.dev.exceptions.UnknownSystemError Signature: ()","title":"UnknownSystemError"},{"location":"api/midgard-dev/#midgarddevlibrary","text":"Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them.","title":"midgard.dev.library"},{"location":"api/midgard-dev/#simplemock","text":"Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on).","title":"SimpleMock"},{"location":"api/midgard-dev/#load_name","text":"Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_name()"},{"location":"api/midgard-dev/#load_path","text":"Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_path()"},{"location":"api/midgard-dev/#midgarddevlog","text":"Midgard library module for logging Description: The Midgard log module provides simple logging functionality. To use it, you must first add a an active logger. This is typically done using the init-functions: init() and/or file_init() . init() initializes a console logger, where logging messages are written to the console. file_init() initializes a file logger, where logging messages are written to a defined file path. Following logging levels are defined: Level Description debug Debug messages info Information messages warn Warning messages error Error messages fatal Fatal error messages To write a log message, simply call log.{level} (e.g. log.info), whereby {level} is a placeholder for the defined logging levels in the table above. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix","title":"midgard.dev.log"},{"location":"api/midgard-dev/#consolelogger","text":"Full name: midgard.dev.log.ConsoleLogger Signature: (log_level: Optional[str] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters","title":"ConsoleLogger"},{"location":"api/midgard-dev/#filelogger","text":"Full name: midgard.dev.log.FileLogger Signature: (file_path: Union[str, pathlib.Path], log_level: Optional[str] = None, prefix: str = '', rotation: Optional[int] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones.","title":"FileLogger"},{"location":"api/midgard-dev/#logger","text":"Full name: midgard.dev.log.Logger Signature: (log_level: Optional[str] = None, prefix: str = '') Abstract class that can be specialized to create new loggers","title":"Logger"},{"location":"api/midgard-dev/#blank","text":"Full name: midgard.dev.log.blank Signature: () -> None Log blank line","title":"blank()"},{"location":"api/midgard-dev/#file_init","text":"Full name: midgard.dev.log.file_init Signature: (file_path: Union[str, pathlib.Path], log_level: Optional[str] = None, prefix: str = '', rotation: Optional[int] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones.","title":"file_init"},{"location":"api/midgard-dev/#init","text":"Full name: midgard.dev.log.init Signature: (log_level: Optional[str] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters","title":"init"},{"location":"api/midgard-dev/#log","text":"Full name: midgard.dev.log.log Signature: (log_text: str, level: str) -> None Log text at the given level","title":"log()"},{"location":"api/midgard-dev/#print_file","text":"Full name: midgard.dev.log.print_file Signature: (log_path: Union[str, pathlib.Path], log_level: str = 'info', print_func: Callable[[str], NoneType] = <built-in function print>) -> None Print a log file with colors, stripping away any item below log_level","title":"print_file()"},{"location":"api/midgard-dev/#midgarddevplugins","text":"Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(*args, **kwargs): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...)","title":"midgard.dev.plugins"},{"location":"api/midgard-dev/#plugin","text":"Full name: midgard.dev.plugins.Plugin Signature: (name: str, function: Callable, file_path: pathlib.Path, sort_value: int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called.","title":"Plugin"},{"location":"api/midgard-dev/#add_alias","text":"Full name: midgard.dev.plugins.add_alias Signature: (package_name: str, alias: str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory.","title":"add_alias()"},{"location":"api/midgard-dev/#call","text":"Full name: midgard.dev.plugins.call Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None, plugin_logger: Optional[Callable[[str], NoneType]] = None, **plugin_args: Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in.","title":"call()"},{"location":"api/midgard-dev/#call_all","text":"Full name: midgard.dev.plugins.call_all Signature: (package_name: str, plugins: Optional[List[str]] = None, part: Optional[str] = None, prefix: Optional[str] = None, plugin_logger: Optional[Callable[[str], NoneType]] = None, **plugin_args: Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins.","title":"call_all()"},{"location":"api/midgard-dev/#doc","text":"Full name: midgard.dev.plugins.doc Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in.","title":"doc()"},{"location":"api/midgard-dev/#doc_all","text":"Full name: midgard.dev.plugins.doc_all Signature: (package_name: str, plugins: Optional[Iterable[str]] = None, prefix: Optional[str] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins.","title":"doc_all()"},{"location":"api/midgard-dev/#exists","text":"Full name: midgard.dev.plugins.exists Signature: (package_name: str, plugin_name: str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise.","title":"exists()"},{"location":"api/midgard-dev/#get","text":"Full name: midgard.dev.plugins.get Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in.","title":"get()"},{"location":"api/midgard-dev/#load","text":"Full name: midgard.dev.plugins.load Signature: (package_name: str, plugin_name: str, prefix: Optional[str] = None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix).","title":"load()"},{"location":"api/midgard-dev/#names","text":"Full name: midgard.dev.plugins.names Signature: (package_name: str, plugins: Optional[Iterable[str]] = None, prefix: Optional[str] = None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins.","title":"names()"},{"location":"api/midgard-dev/#parts","text":"Full name: midgard.dev.plugins.parts Signature: (package_name: str, plugin_name: str, prefix: Optional[str] = None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts.","title":"parts()"},{"location":"api/midgard-dev/#register","text":"Full name: midgard.dev.plugins.register Signature: (func: Callable, name: Optional[str] = None, sort_value: int = 0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files. Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered.","title":"register()"},{"location":"api/midgard-dev/#register_named","text":"Full name: midgard.dev.plugins.register_named Signature: (name: str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function.","title":"register_named()"},{"location":"api/midgard-dev/#register_ordered","text":"Full name: midgard.dev.plugins.register_ordered Signature: (sort_value: int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function.","title":"register_ordered()"},{"location":"api/midgard-dev/#signature","text":"Full name: midgard.dev.plugins.signature Signature: (package_name: str, plugin_name: str, part: Optional[str] = None, prefix: Optional[str] = None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin","title":"signature()"},{"location":"api/midgard-dev/#midgarddevprofiler","text":"Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler.","title":"midgard.dev.profiler"},{"location":"api/midgard-dev/#cprofile","text":"Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program","title":"CProfile"},{"location":"api/midgard-dev/#lineprofiler","text":"Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail","title":"LineProfiler"},{"location":"api/midgard-dev/#profiler","text":"Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers","title":"Profiler"},{"location":"api/midgard-dev/#midgarddevtimer","text":"Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details.","title":"midgard.dev.timer"},{"location":"api/midgard-dev/#accumulatedtimer","text":"Full name: midgard.dev.timer.AccumulatedTimer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Optional[Callable[[str], NoneType]] = functools.partial(<function log at 0x7f174b56be20>, level='info')) -> None","title":"AccumulatedTimer"},{"location":"api/midgard-dev/#timer","text":"Full name: midgard.dev.timer.Timer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Optional[Callable[[str], NoneType]] = functools.partial(<function log at 0x7f174b56be20>, level='info')) -> None Class for timing running time of functions and code blocks.","title":"Timer"},{"location":"api/midgard-dev/#midgarddevutil","text":"Midgard library module with utility functions for easier script development Example: from midgard.dev import util directory, date = util.parse_args('string', 'date') Description: This module provides the boilerplate code necessary for starting a script. In particular handling of command line arguments and default options including --help are done.","title":"midgard.dev.util"},{"location":"api/midgard-dev/#command-str","text":"COMMAND = 'generate_api '","title":"COMMAND (str)"},{"location":"api/midgard-dev/#check_help_and_version","text":"Full name: midgard.dev.util.check_help_and_version Signature: (module: str, doc_module: str = None, replace_vars: Dict[str, str] = {}) -> None Show help or version if asked for Show the help message parsed from the script's docstring if -h or --help option is given. Show the script's version if --version is given. Args: module : Module name. doc_module : Module containing help text. replace_vars : Dictionary with variable for replacement in docstring","title":"check_help_and_version()"},{"location":"api/midgard-dev/#check_options","text":"Full name: midgard.dev.util.check_options Signature: (*options: Tuple[str]) -> str Check if any of a list of options is specified on the command line Returns the actual option that is specified. The first option specified on the command line is returned if there are several matches. Returns the empty string if no option is specified. This means that this method works fine also in a boolean context, for example if check_options('-F', '--force'): do_something() Args: options : Strings specifying which options to check for, including '-'-prefix. Returns: String : Option that is specified, blank string if no option is specified","title":"check_options()"},{"location":"api/midgard-dev/#get_callers","text":"Full name: midgard.dev.util.get_callers Signature: () -> str Get a list of methods calling this function Returns: Lists all methods calling the function","title":"get_callers()"},{"location":"api/midgard-dev/#get_pid_and_server","text":"Full name: midgard.dev.util.get_pid_and_server Signature: () -> str Find process id and name of server the analysis is running on Use the platform.uname to find servername instead of os.uname because the latter is not supported on Windows. Returns: Process id and name of server","title":"get_pid_and_server()"},{"location":"api/midgard-dev/#get_program_info","text":"Full name: midgard.dev.util.get_program_info Signature: (module: str) -> str Get the name and the version of the running program Args: module : Module name. Returns: Program name and version","title":"get_program_info()"},{"location":"api/midgard-dev/#get_program_name","text":"Full name: midgard.dev.util.get_program_name Signature: () -> str Get the name of the running program Returns: String trying to be similar to how the user called the program.","title":"get_program_name()"},{"location":"api/midgard-dev/#get_python_version","text":"Full name: midgard.dev.util.get_python_version Signature: () -> str Find python version used Returns: Name of executable and version number","title":"get_python_version()"},{"location":"api/midgard-dev/#no_traceback","text":"Full name: midgard.dev.util.no_traceback Signature: (func) Decorator for turning off traceback, instead printing a simple error message Use the option --show_tb to show the traceback anyway.","title":"no_traceback()"},{"location":"api/midgard-dev/#not_implemented","text":"Full name: midgard.dev.util.not_implemented Signature: () -> None A placeholder for functions that are not implemented yet A note about the missing implementation is written to the log.","title":"not_implemented()"},{"location":"api/midgard-dev/#options2args","text":"Full name: midgard.dev.util.options2args Signature: (options: List[str]) -> Union[List[str], Dict[str, str]] Convert a list of command line options to a args and kwargs The options should be specified as a string with the necessary - or -- in front and options with a value should by separated by = (e.g. --station=stas). Args: options : List with options Returns: Tuple with non-keyword arguments and with keyword arguments","title":"options2args()"},{"location":"api/midgard-dev/#parse_args","text":"Full name: midgard.dev.util.parse_args Signature: (*param_types: Tuple[str], doc_module: str = None) -> Union[Any, List[Any]] Parse command line arguments and general options Parse arguments from the given parameter types. Args: param_types : Strings describing the expected parameter types. Each string must be one of the keys in #_PARSERS. doc_module : Module containing help text. Returns: List of command line arguments parsed according to param_types.","title":"parse_args()"},{"location":"api/midgard-dev/#read_option_value","text":"Full name: midgard.dev.util.read_option_value Signature: (option: str, default: str = '') -> str Read the value of one command line option The option should be specified as a string with the necessary - or -- in front. If that option is not one of the command line arguments, default is returned. If there is a value following the option that value is returned as a string (separated by =). If there are several occurences of the option, the first one is returned. Args: option : Option specified with the leading - or --. default : Optional default value that is returned if the option is not specified. Returns: The option or the value of the option. The default value if the option is not specified.","title":"read_option_value()"},{"location":"api/midgard-dev/#write_requirements","text":"Full name: midgard.dev.util.write_requirements Signature: (file_path: Union[str, pathlib.Path]) -> None Write requirements (python modules) to file for reproducibility. Note that this only stores the modules that have been imported, and that have a __version__ -attribute (see PEP 396 - https://www.python.org/dev/peps/pep-0396/) Args: file_path : File path.","title":"write_requirements()"},{"location":"api/midgard-files/","text":"midgard.files midgard.files.dates Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' date_vars () Full name: midgard.files.dates.date_vars Signature: (date: Union[datetime.date, datetime.datetime, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date. midgard.files.dependencies Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed. add () Full name: midgard.files.dependencies.add Signature: (*file_paths: Union[str, pathlib.Path], label: str = '') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies. changed () Full name: midgard.files.dependencies.changed Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise. get_md5 () Full name: midgard.files.dependencies.get_md5 Signature: (file_path: Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file. get_paths_with_label () Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path: Union[str, pathlib.Path], label_pattern: str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths. get_timestamp () Full name: midgard.files.dependencies.get_timestamp Signature: (file_path: Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file. init () Full name: midgard.files.dependencies.init Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. write () Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file midgard.files.files Utilities for working with files move () Full name: midgard.files.files.move Signature: (from_path: Union[str, pathlib.Path], to_path: Union[str, pathlib.Path], overwrite: bool = True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten. open () Full name: midgard.files.files.open Signature: (file_path: Union[str, pathlib.Path], create_dirs: bool = False, open_as_gzip: Optional[bool] = None, **open_args: Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file. midgard.files.url Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment. URL Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"midgard.files"},{"location":"api/midgard-files/#midgardfiles","text":"","title":"midgard.files"},{"location":"api/midgard-files/#midgardfilesdates","text":"Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency.","title":"midgard.files.dates"},{"location":"api/midgard-files/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-files/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-files/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-files/#date_vars","text":"Full name: midgard.files.dates.date_vars Signature: (date: Union[datetime.date, datetime.datetime, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date.","title":"date_vars()"},{"location":"api/midgard-files/#midgardfilesdependencies","text":"Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed.","title":"midgard.files.dependencies"},{"location":"api/midgard-files/#add","text":"Full name: midgard.files.dependencies.add Signature: (*file_paths: Union[str, pathlib.Path], label: str = '') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies.","title":"add()"},{"location":"api/midgard-files/#changed","text":"Full name: midgard.files.dependencies.changed Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise.","title":"changed()"},{"location":"api/midgard-files/#get_md5","text":"Full name: midgard.files.dependencies.get_md5 Signature: (file_path: Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file.","title":"get_md5()"},{"location":"api/midgard-files/#get_paths_with_label","text":"Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path: Union[str, pathlib.Path], label_pattern: str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths.","title":"get_paths_with_label()"},{"location":"api/midgard-files/#get_timestamp","text":"Full name: midgard.files.dependencies.get_timestamp Signature: (file_path: Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file.","title":"get_timestamp()"},{"location":"api/midgard-files/#init","text":"Full name: midgard.files.dependencies.init Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums.","title":"init()"},{"location":"api/midgard-files/#write","text":"Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file","title":"write()"},{"location":"api/midgard-files/#midgardfilesfiles","text":"Utilities for working with files","title":"midgard.files.files"},{"location":"api/midgard-files/#move","text":"Full name: midgard.files.files.move Signature: (from_path: Union[str, pathlib.Path], to_path: Union[str, pathlib.Path], overwrite: bool = True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten.","title":"move()"},{"location":"api/midgard-files/#open","text":"Full name: midgard.files.files.open Signature: (file_path: Union[str, pathlib.Path], create_dirs: bool = False, open_as_gzip: Optional[bool] = None, **open_args: Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file.","title":"open()"},{"location":"api/midgard-files/#midgardfilesurl","text":"Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment.","title":"midgard.files.url"},{"location":"api/midgard-files/#url","text":"Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"URL"},{"location":"api/midgard-gnss/","text":"midgard.gnss midgard.gnss.antenna_calibration Handling of GNSS antenna calibration information based on ANTEX file Description: The module includes a class for handling of GNSS antenna information based on read GNSS ANTEX file (see Rothacher, 2010). Reference: Rothacher, M. and Schmid, R. (2010): \"ANTEX: The antenna exchange format\", version 1.4, Forschungseinrichtung Satellitengeod\u00e4sie, TU M\u00fcnchen Example: Import AntennaCalibration class from midgard.gnss.antenna_calibration import AntennaCalibration Get instance of AntennaCalibration class by defining ANTEX file path ant = AntennaCalibration(file_path=\"igs14.atx\") AntennaCalibration Full name: midgard.gnss.antenna_calibration.AntennaCalibration Signature: (file_path: Union[str, pathlib.PosixPath]) -> None A class for representing GNSS antenna calibration data The attribute \"data\" is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: | Value | Type | Description | |--------------------|---------------------------------------------------------------------------------------------| | azi | numpy.ndarray | Array with azimuth-elevation dependent antenna correction in [mm] with | | | | the shape: number of azimuth values x number of elevation values. | | azimuth | numpy.ndarray | List with azimuth values in [rad] corresponding to antenna corrections | | | | given in azi . | | cospar_id | str | COSPAR ID : yyyy -> year when the satellite was put in | | | | orbit, xxx -> sequential satellite number for that year, a -> alpha | | | | numeric sequence number within a launch | | elevation | numpy.ndarray | List with elevation values in [rad] corresponding to antenna | | | | corrections given in azi or noazi . | | | str | Frequency identifier (e.g. G01 - GPS L1) | | neu | list | North, East and Up eccentricities in [m]. The eccentricities of the | | | | mean antenna phase center is given relative to the antenna reference | | | | point (ARP) for receiver antennas or to the center of mass of the | | | | satellite in X-, Y- and Z-direction. | | noazi | numpy.ndarray | List with elevation dependent (non-azimuth-dependent) antenna | | | | correction in [mm]. | | | str | Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number | | | str | Receiver antenna name together with radome code | | sat_code | str | Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number | | sat_type | str | Satellite type (e.g. BLOCK IIA) | | valid_from | datetime.datetime | Start of validity period of satellite in GPS time | | valid_until | datetime.datetime | End of validity period of satellite in GPS time | Attributes: data (dict): Data read from GNSS Antenna Exchange (ANTEX) file file_path (str): ANTEX file path Methods: satellite_phase_center_offset(): Determine satellite phase center offset correction vectors given in ITRS satellite_type(): Get satellite type from ANTEX file (e.g. BLOCK IIF, GALILEO-1, GALILEO-2, GLONASS-M, BEIDOU-2G, ...) _used_date(): Choose correct date for use of satellite antenna corrections midgard.gnss.compute_dops Compute DOP (dilution of precision) Description: Calculate GDOP, PDOP, TDOP, HDOP and VDOP based on elevation and azimuth between station and satellite for each observation epoch. compute_dops () Full name: midgard.gnss.compute_dops.compute_dops Signature: (az: numpy.ndarray, el: numpy.ndarray) -> Tuple[numpy.ndarray, ...] Compute dilution of precision (DOP) for an observation epoch It should be noted, that the weight of observations is not considered. The observation weight matrix is assumed to be an identity matrix. The cofactor matrix Q is related to a topocentric coordinate system (north, east, up): | q_nn q_ne q_nu q_nt | Q = | q_ne q_ee q_eu q_et | | q_nu q_eu q_nn q_nt | | q_nt q_et q_nt q_tt | Reference: Banerjee, P. and Bose, A. (1996): \"Evaluation of GPS PDOP from elevation and azimuth of satellites\", Indian Journal of Radio & Space Physics, Vol. 25, April 1996, pp. 110-113 Args: az : Satellite azimuth angle (radians) el : Satellite elevation angle (radians) Returns: Tuple with GDOP, PDOP, TDOP, HDOP and VDOP midgard.gnss.gnss Midgard library module including functions for GNSS modeling Example: from migard.gnss import gnss Description: This module will provide functions for GNSS modeling. get_number_of_satellites () Full name: midgard.gnss.gnss.get_number_of_satellites Signature: (systems: numpy.ndarray, satellites: numpy.ndarray, epochs: numpy.ndarray) -> numpy.ndarray Get number of satellites per epoch Args: satellites : Array with satellite PRN number together with GNSS identifier (e.g. G07) systems : Array with GNSS identifiers (e.g. G, E, R, ...) epochs : Array with observation epochs (e.g. as datetime objects) Returns: Number of satellites per epoch get_rinex_file_version () Full name: midgard.gnss.gnss.get_rinex_file_version Signature: (file_path: pathlib.PosixPath) -> str Get RINEX file version for a given file path Args: file_path : File path. Returns: RINEX file version obstype_to_freq () Full name: midgard.gnss.gnss.obstype_to_freq Signature: (sys: str, obstype: str) -> float Get GNSS frequency based on given GNSS observation type Args: sys : GNSS identifier (e.g. 'E', 'G', ...) obstype : Observation type (e.g. 'L1', 'P1', 'C1X', ...) Return: GNSS frequency in [Hz] midgard.gnss.klobuchar Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013 klobuchar () Full name: midgard.gnss.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7f174b56be20>, level='debug')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard. main () Full name: midgard.gnss.klobuchar.main Signature: () midgard.gnss.solution_validation comp_quality_indicators () Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat: numpy.ndarray) -> tuple Compute quality indicators Following quality indicators are computed 1. compute the standard error ellipse(SEE) 2. compute the distance root mean squared (DRMS) 3. compute the circular error probable (CEP) Args: sol_vc_mat : Variance-covariance matrix of the unknown Returns: Tuple with DRMS, CEP and SEE epilog (str) epilog = '\\n**EXAMPLE**\\n sol_validation (residuals, alpha_sign_level n_params)\\n args:\\n residuals (I): postfit residuals \\n alpha_sign_level(I): alpha significance level and defines the rejection area.\\n possible values of alpha = 0.05 (95%), 0.01 (99%) and 0.001 (99.9%)\\n n_params (I): number of estimated parameters (states).\\n \\n\\nKeywords: Chi-square distribution,\\n' get_my_parser () Full name: midgard.gnss.solution_validation.get_my_parser Signature: () main () Full name: midgard.gnss.solution_validation.main Signature: () Main program for testing solution validation implementation TODO: This should be done via midgard/tests/gnss !!! prolog (str) prolog = '\\n**PROGRAM**\\n solution_validation.py\\n \\n**PURPOSE**\\n Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that\\n are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1.\\n GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and\\n defines the rejection level of the crossing events. \\n Note that this is different from the false alarm rate, which instead refers to error type I\\n \\n**USAGE**\\n' sol_validation () Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals: numpy.ndarray, alpha_siglev: float, n_params: int = 4) -> bool Validating the GNSS solution is carried out using Chi-square test Use Chi-square test for outlier detection and rejection. Args: residuals : Postfit residuals for all satellites in each epoch alpha_siglev : Alpha significance level n_params : Number of parameters (states), normally 4 parameters for station coordinates and receiver clock Returns: Array containing False for observations to throw away.","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnss","text":"","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnssantenna_calibration","text":"Handling of GNSS antenna calibration information based on ANTEX file Description: The module includes a class for handling of GNSS antenna information based on read GNSS ANTEX file (see Rothacher, 2010). Reference: Rothacher, M. and Schmid, R. (2010): \"ANTEX: The antenna exchange format\", version 1.4, Forschungseinrichtung Satellitengeod\u00e4sie, TU M\u00fcnchen Example:","title":"midgard.gnss.antenna_calibration"},{"location":"api/midgard-gnss/#import-antennacalibration-class","text":"from midgard.gnss.antenna_calibration import AntennaCalibration","title":"Import AntennaCalibration class"},{"location":"api/midgard-gnss/#get-instance-of-antennacalibration-class-by-defining-antex-file-path","text":"ant = AntennaCalibration(file_path=\"igs14.atx\")","title":"Get instance of AntennaCalibration class by defining ANTEX file path"},{"location":"api/midgard-gnss/#antennacalibration","text":"Full name: midgard.gnss.antenna_calibration.AntennaCalibration Signature: (file_path: Union[str, pathlib.PosixPath]) -> None A class for representing GNSS antenna calibration data The attribute \"data\" is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: | Value | Type | Description | |--------------------|---------------------------------------------------------------------------------------------| | azi | numpy.ndarray | Array with azimuth-elevation dependent antenna correction in [mm] with | | | | the shape: number of azimuth values x number of elevation values. | | azimuth | numpy.ndarray | List with azimuth values in [rad] corresponding to antenna corrections | | | | given in azi . | | cospar_id | str | COSPAR ID : yyyy -> year when the satellite was put in | | | | orbit, xxx -> sequential satellite number for that year, a -> alpha | | | | numeric sequence number within a launch | | elevation | numpy.ndarray | List with elevation values in [rad] corresponding to antenna | | | | corrections given in azi or noazi . | | | str | Frequency identifier (e.g. G01 - GPS L1) | | neu | list | North, East and Up eccentricities in [m]. The eccentricities of the | | | | mean antenna phase center is given relative to the antenna reference | | | | point (ARP) for receiver antennas or to the center of mass of the | | | | satellite in X-, Y- and Z-direction. | | noazi | numpy.ndarray | List with elevation dependent (non-azimuth-dependent) antenna | | | | correction in [mm]. | | | str | Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number | | | str | Receiver antenna name together with radome code | | sat_code | str | Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number | | sat_type | str | Satellite type (e.g. BLOCK IIA) | | valid_from | datetime.datetime | Start of validity period of satellite in GPS time | | valid_until | datetime.datetime | End of validity period of satellite in GPS time | Attributes: data (dict): Data read from GNSS Antenna Exchange (ANTEX) file file_path (str): ANTEX file path Methods: satellite_phase_center_offset(): Determine satellite phase center offset correction vectors given in ITRS satellite_type(): Get satellite type from ANTEX file (e.g. BLOCK IIF, GALILEO-1, GALILEO-2, GLONASS-M, BEIDOU-2G, ...) _used_date(): Choose correct date for use of satellite antenna corrections","title":"AntennaCalibration"},{"location":"api/midgard-gnss/#midgardgnsscompute_dops","text":"Compute DOP (dilution of precision) Description: Calculate GDOP, PDOP, TDOP, HDOP and VDOP based on elevation and azimuth between station and satellite for each observation epoch.","title":"midgard.gnss.compute_dops"},{"location":"api/midgard-gnss/#compute_dops","text":"Full name: midgard.gnss.compute_dops.compute_dops Signature: (az: numpy.ndarray, el: numpy.ndarray) -> Tuple[numpy.ndarray, ...] Compute dilution of precision (DOP) for an observation epoch It should be noted, that the weight of observations is not considered. The observation weight matrix is assumed to be an identity matrix. The cofactor matrix Q is related to a topocentric coordinate system (north, east, up): | q_nn q_ne q_nu q_nt | Q = | q_ne q_ee q_eu q_et | | q_nu q_eu q_nn q_nt | | q_nt q_et q_nt q_tt | Reference: Banerjee, P. and Bose, A. (1996): \"Evaluation of GPS PDOP from elevation and azimuth of satellites\", Indian Journal of Radio & Space Physics, Vol. 25, April 1996, pp. 110-113 Args: az : Satellite azimuth angle (radians) el : Satellite elevation angle (radians) Returns: Tuple with GDOP, PDOP, TDOP, HDOP and VDOP","title":"compute_dops()"},{"location":"api/midgard-gnss/#midgardgnssgnss","text":"Midgard library module including functions for GNSS modeling Example: from migard.gnss import gnss Description: This module will provide functions for GNSS modeling.","title":"midgard.gnss.gnss"},{"location":"api/midgard-gnss/#get_number_of_satellites","text":"Full name: midgard.gnss.gnss.get_number_of_satellites Signature: (systems: numpy.ndarray, satellites: numpy.ndarray, epochs: numpy.ndarray) -> numpy.ndarray Get number of satellites per epoch Args: satellites : Array with satellite PRN number together with GNSS identifier (e.g. G07) systems : Array with GNSS identifiers (e.g. G, E, R, ...) epochs : Array with observation epochs (e.g. as datetime objects) Returns: Number of satellites per epoch","title":"get_number_of_satellites()"},{"location":"api/midgard-gnss/#get_rinex_file_version","text":"Full name: midgard.gnss.gnss.get_rinex_file_version Signature: (file_path: pathlib.PosixPath) -> str Get RINEX file version for a given file path Args: file_path : File path. Returns: RINEX file version","title":"get_rinex_file_version()"},{"location":"api/midgard-gnss/#obstype_to_freq","text":"Full name: midgard.gnss.gnss.obstype_to_freq Signature: (sys: str, obstype: str) -> float Get GNSS frequency based on given GNSS observation type Args: sys : GNSS identifier (e.g. 'E', 'G', ...) obstype : Observation type (e.g. 'L1', 'P1', 'C1X', ...) Return: GNSS frequency in [Hz]","title":"obstype_to_freq()"},{"location":"api/midgard-gnss/#midgardgnssklobuchar","text":"Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013","title":"midgard.gnss.klobuchar"},{"location":"api/midgard-gnss/#klobuchar","text":"Full name: midgard.gnss.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7f174b56be20>, level='debug')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard.","title":"klobuchar()"},{"location":"api/midgard-gnss/#main","text":"Full name: midgard.gnss.klobuchar.main Signature: ()","title":"main()"},{"location":"api/midgard-gnss/#midgardgnsssolution_validation","text":"","title":"midgard.gnss.solution_validation"},{"location":"api/midgard-gnss/#comp_quality_indicators","text":"Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat: numpy.ndarray) -> tuple Compute quality indicators Following quality indicators are computed 1. compute the standard error ellipse(SEE) 2. compute the distance root mean squared (DRMS) 3. compute the circular error probable (CEP) Args: sol_vc_mat : Variance-covariance matrix of the unknown Returns: Tuple with DRMS, CEP and SEE","title":"comp_quality_indicators()"},{"location":"api/midgard-gnss/#epilog-str","text":"epilog = '\\n**EXAMPLE**\\n sol_validation (residuals, alpha_sign_level n_params)\\n args:\\n residuals (I): postfit residuals \\n alpha_sign_level(I): alpha significance level and defines the rejection area.\\n possible values of alpha = 0.05 (95%), 0.01 (99%) and 0.001 (99.9%)\\n n_params (I): number of estimated parameters (states).\\n \\n\\nKeywords: Chi-square distribution,\\n'","title":"epilog (str)"},{"location":"api/midgard-gnss/#get_my_parser","text":"Full name: midgard.gnss.solution_validation.get_my_parser Signature: ()","title":"get_my_parser()"},{"location":"api/midgard-gnss/#main_1","text":"Full name: midgard.gnss.solution_validation.main Signature: () Main program for testing solution validation implementation","title":"main()"},{"location":"api/midgard-gnss/#todo-this-should-be-done-via-midgardtestsgnss","text":"","title":"TODO: This should be done via midgard/tests/gnss !!!"},{"location":"api/midgard-gnss/#prolog-str","text":"prolog = '\\n**PROGRAM**\\n solution_validation.py\\n \\n**PURPOSE**\\n Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that\\n are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1.\\n GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and\\n defines the rejection level of the crossing events. \\n Note that this is different from the false alarm rate, which instead refers to error type I\\n \\n**USAGE**\\n'","title":"prolog (str)"},{"location":"api/midgard-gnss/#sol_validation","text":"Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals: numpy.ndarray, alpha_siglev: float, n_params: int = 4) -> bool Validating the GNSS solution is carried out using Chi-square test Use Chi-square test for outlier detection and rejection. Args: residuals : Postfit residuals for all satellites in each epoch alpha_siglev : Alpha significance level n_params : Number of parameters (states), normally 4 parameters for station coordinates and receiver clock Returns: Array containing False for observations to throw away.","title":"sol_validation()"},{"location":"api/midgard-ionosphere/","text":"midgard.ionosphere midgard.ionosphere.klobuchar Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013 klobuchar () Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7f6bf7042550>, level='debug')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard. main () Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphere","text":"","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphereklobuchar","text":"Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013","title":"midgard.ionosphere.klobuchar"},{"location":"api/midgard-ionosphere/#klobuchar","text":"Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7f6bf7042550>, level='debug')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard.","title":"klobuchar()"},{"location":"api/midgard-ionosphere/#main","text":"Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"main()"},{"location":"api/midgard-math/","text":"midgard.math midgard.math.constant Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit). Constant Full name: midgard.math.constant.Constant Signature: () -> None constant (Constant) constant = Constant('/home/kirann/miniconda3/envs/where/lib/python3.10/site-packages/midgard/math/constant.txt') midgard.math.ellipsoid Midgard library module for handling Earth ellipsoids Description: Ellipsoid Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name: str, a: float, f_inv: float, description: str) -> None Ellipsoid(name: str, a: float, f_inv: float, description: str) GRS80 (Ellipsoid) GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS') IERS2003 (Ellipsoid) IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12') IERS2010 (Ellipsoid) IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18') WGS72 (Ellipsoid) WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72') WGS84 (Ellipsoid) WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS') get () Full name: midgard.math.ellipsoid.get Signature: (ellipsoid: str) -> 'Ellipsoid' Get an ellipsoid by name sphere (Ellipsoid) sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius') midgard.math.interpolation Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) barycentric_interpolator () Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function cubic () Full name: midgard.math.interpolation.cubic Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function get_interpolator () Full name: midgard.math.interpolation.get_interpolator Signature: (name: str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name. interpolate () Full name: midgard.math.interpolation.interpolate Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values. interpolate_with_derivative () Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, dx: float = 0.5, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives. interpolated_univariate_spline () Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function interpolators () Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators. lagrange () Full name: midgard.math.interpolation.lagrange Signature: (x: numpy.ndarray, y: numpy.ndarray, *, window: int = 10, bounds_error: bool = True, assume_sorted: bool = False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function. linear () Full name: midgard.math.interpolation.linear Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function register_interpolator () Full name: midgard.math.interpolation.register_interpolator Signature: (func: Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function. midgard.math.linear_regression Midgard library module for linear regression Description: The 'statsmodels' module is used for the linear regression. Outlier can be rejected beside normal linear regression analysis. Hereby a linear regression analysis is carried out, whereby a linear trend is estimated of the given data. The root-mean square (RMS) of the residuals (observation - linear trend) is used to detect outliers. As default the following outlier limit is defined: limit = outlier_limit_factor * RMS (with outlier_limit_factor=1.0) The 'outlier_limit_factor' can be chosen as argument by initialization of a LinearRegression class object. In addition the number of iteration for the outlier detection can be chosen with the argument 'outlier_iteration'. Example: Import Midgard LinearRegression class of linear_regression module from midgard.math.linear_regression import LinearRegression Generate LinearRegression object linreg = LinearRegression(x,y) Get solution interception = linreg.interception slope = linreg.slope LinearRegression Full name: midgard.math.linear_regression.LinearRegression Signature: (x: Union[numpy.ndarray, list], y: Union[numpy.ndarray, list], reject_outlier: bool = False, outlier_limit_factor: float = 1.0, outlier_iteration: int = 1) -> None Linear regression class Following arguments can be chosen by initialization of LinearRegression class objects: | Arguments | Type | Description | |:----------------------| :----------| :---------------------------------------------------------------------| | outlier_limit_factor | float | RMS of residuals are used for detecting outliers, whereby | | | | 'outlier_limit_factor' * 'RMS' is used as limit. As default is | | | | 'outlier_limit_factor' = 1.0 chosen. | | outlier_iteration | int | Number of iteration used to detect and reject outliers. Default is 1. | | reject_outlier | bool | Determine if outliers should be detected and rejected. Default is | | | | 'False', which means that no outliers are rejected. | | x | np.ndarray | X training data | | y | np.ndarray | Y target data | midgard.math.nputil Utility wrapper for numpy functions Makes sure numpy functions can be called in a similar fashion for different use cases + both 1- and 2-dimensional input + both single values and arrays HashArray Full name: midgard.math.nputil.HashArray Signature: (val) col () Full name: midgard.math.nputil.col Signature: (vector) hashable () Full name: midgard.math.nputil.hashable Signature: (func) Decorator for functions with numpy arrays as input arguments that will benefit from caching Example: from midgard.math import nputil from functools import lru_cache @nputil.hashable @lru_cache() def test_func(a: np.ndarray, b: np.ndarray = None) do_something return something norm () Full name: midgard.math.nputil.norm Signature: (vector) row () Full name: midgard.math.nputil.row Signature: (vector) take () Full name: midgard.math.nputil.take Signature: (vector, item) unit_vector () Full name: midgard.math.nputil.unit_vector Signature: (vector) midgard.math.planetary_motion Midgard library for planetary motion Example: from migard.math import planetary_motion findsun () Full name: midgard.math.planetary_motion.findsun Signature: (time: 'Time') -> numpy.ndarray Obtains the position vector of the Sun in relation to Earth (in ECEF). This routine is a reimplementation of routine findSun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Sun position vector given in ECEF [m] gsdtime_sun () Full name: midgard.math.planetary_motion.gsdtime_sun Signature: (time: 'Time') -> Tuple[numpy.ndarray] Get position of the sun (low-precision) This routine is a reimplementation of routine GSDtime_sun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Tuple with following entries: Elements Description gstr GMST0 (to go from ECEF to inertial) [deg] slong Sun longitude [deg] sra Sun right Ascension [deg] sdec Sun declination in [deg] midgard.math.plate_motion Midgard library module for handling tectonic plate motion Description: Example: import numpy as np from midgard.math.plate_motion import PlateMotion pm = PlateMotion(plate=\"eura\") pos = np.array([2102928.189605, 721619.617278, 5958196.398820]) # in meter vel = pm.get_velocity(pos) # in mm/yr PlateMotion Full name: midgard.math.plate_motion.PlateMotion Signature: (plate: str, model: str = 'itrf2014') -> None A class for handling of tectonic plate motion midgard.math.rotation Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]]) R1 () Full name: midgard.math.rotation.R1 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R2 () Full name: midgard.math.rotation.R2 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R3 () Full name: midgard.math.rotation.R3 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR1 () Full name: midgard.math.rotation.dR1 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR2 () Full name: midgard.math.rotation.dR2 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR3 () Full name: midgard.math.rotation.dR3 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. enu2trs () Full name: midgard.math.rotation.enu2trs Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. np_float (TypeVar) np_float = ~np_float trs2enu () Full name: midgard.math.rotation.trs2enu Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. midgard.math.spatial_interpolation Methods for spatial interpolation in numpy arrays Description: Example: TODO interpolate_for_position () Full name: midgard.math.spatial_interpolation.interpolate_for_position Signature: (grid_x: numpy.ndarray, grid_y: numpy.ndarray, values: numpy.ndarray, x: float, y: float, method: str = 'linear') -> float Interpolation in grid with size (n, m) for a given position Interpolation is based on scipy.interpolate.griddata module. More information about this module can be found under: https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html Args: grid_x : (n,m) Array with x-positions for each grid point grid_y : (n,m) Array with y-positions for each grid point values : (n,m) Array with data values for each grid point x : x-position y : y-position method : Method of interpolation: linear: tessellate the input point set to N-D simplices, and interpolate linearly on each simplex nearest: value of data point closest to the point of interpolation cubic: value determined from a piecewise cubic Returns: Interpolated value in data grid for a given position midgard.math.transformation Midgard library module for handling of geodetic conversions Description: delta_acr2trs_posvel () Full name: midgard.math.transformation.delta_acr2trs_posvel Signature: (acr: 'AcrPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ACR to TRS delta_enu2trs () Full name: midgard.math.transformation.delta_enu2trs Signature: (enu: 'EnuPositionDelta') -> 'TrsPositionDelta' Convert position deltas from ENU to TRS delta_enu2trs_posvel () Full name: midgard.math.transformation.delta_enu2trs_posvel Signature: (enu: 'EnuPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ENU to TRS delta_trs2acr_posvel () Full name: midgard.math.transformation.delta_trs2acr_posvel Signature: (trs: 'TrsPosVelDelta') -> 'AcrPosVelDelta' Convert position deltas from TRS to ACR delta_trs2enu () Full name: midgard.math.transformation.delta_trs2enu Signature: (trs: 'TrsPositionDelta') -> 'EnuPositionDelta' Convert position deltas from TRS to ENU delta_trs2enu_posvel () Full name: midgard.math.transformation.delta_trs2enu_posvel Signature: (trs: 'TrsPosVelDelta') -> 'EnuPosVelDelta' Convert position deltas from TRS to ENU kepler2trs () Full name: midgard.math.transformation.kepler2trs Signature: (kepler: 'KeplerPosVel') -> 'TrsPosVel' Compute orbit position and velocity vector in geocentric equatorial coordinate system based on Keplerian elements for elliptic orbits. The implementation is based on Section 2.2.3 in :cite: montenbruck2012 . llh2trs () Full name: midgard.math.transformation.llh2trs Signature: (llh: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Reimplementation of GD2GCE.for from the IUA SOFA software collection. trs2kepler () Full name: midgard.math.transformation.trs2kepler Signature: (trs: 'TrsPosVel') -> 'KeplerPosVel' Compute Keplerian elements for elliptic orbit based on orbit position and velocity vector given in ITRS. The used equations are described in Section 2.2.4 in Montenbruck :cite: montenbruck2012 . The position and velocity vector in ITRS and GM must be given in consistent units, which are [m], [m/s] and [m^3/s^2]. The resulting unit of the semimajor axis is implied by the unity of the position vector, i.e. [m]. .. note:: The function cannot be used with position/velocity vectors describing a circular or non-inclined orbit. Returns: tuple with numpy.ndarray types: Tuple with following Keplerian elements: =============== ====== ================================================================================== Keys Unit Description =============== ====== ================================================================================== a m Semimajor axis e Eccentricity of the orbit i rad Inclination Omega rad Right ascension of the ascending node omega rad Argument of perigee E rad Eccentric anomaly =============== ====== ================================================================================== trs2llh () Full name: midgard.math.transformation.trs2llh Signature: (trs: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Reimplementation of GC2GDE.for from the IUA SOFA software collection. midgard.math.unit Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory. Unit Full name: midgard.math.unit.Unit Signature: (from_unit: str, to_unit: Optional[str] = None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass. np_float (TypeVar) np_float = ~np_float","title":"midgard.math"},{"location":"api/midgard-math/#midgardmath","text":"","title":"midgard.math"},{"location":"api/midgard-math/#midgardmathconstant","text":"Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit).","title":"midgard.math.constant"},{"location":"api/midgard-math/#constant","text":"Full name: midgard.math.constant.Constant Signature: () -> None","title":"Constant"},{"location":"api/midgard-math/#constant-constant","text":"constant = Constant('/home/kirann/miniconda3/envs/where/lib/python3.10/site-packages/midgard/math/constant.txt')","title":"constant (Constant)"},{"location":"api/midgard-math/#midgardmathellipsoid","text":"Midgard library module for handling Earth ellipsoids Description:","title":"midgard.math.ellipsoid"},{"location":"api/midgard-math/#ellipsoid","text":"Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name: str, a: float, f_inv: float, description: str) -> None Ellipsoid(name: str, a: float, f_inv: float, description: str)","title":"Ellipsoid"},{"location":"api/midgard-math/#grs80-ellipsoid","text":"GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')","title":"GRS80 (Ellipsoid)"},{"location":"api/midgard-math/#iers2003-ellipsoid","text":"IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12')","title":"IERS2003 (Ellipsoid)"},{"location":"api/midgard-math/#iers2010-ellipsoid","text":"IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18')","title":"IERS2010 (Ellipsoid)"},{"location":"api/midgard-math/#wgs72-ellipsoid","text":"WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72')","title":"WGS72 (Ellipsoid)"},{"location":"api/midgard-math/#wgs84-ellipsoid","text":"WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS')","title":"WGS84 (Ellipsoid)"},{"location":"api/midgard-math/#get","text":"Full name: midgard.math.ellipsoid.get Signature: (ellipsoid: str) -> 'Ellipsoid' Get an ellipsoid by name","title":"get()"},{"location":"api/midgard-math/#sphere-ellipsoid","text":"sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius')","title":"sphere (Ellipsoid)"},{"location":"api/midgard-math/#midgardmathinterpolation","text":"Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","title":"midgard.math.interpolation"},{"location":"api/midgard-math/#barycentric_interpolator","text":"Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function","title":"barycentric_interpolator()"},{"location":"api/midgard-math/#cubic","text":"Full name: midgard.math.interpolation.cubic Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function","title":"cubic()"},{"location":"api/midgard-math/#get_interpolator","text":"Full name: midgard.math.interpolation.get_interpolator Signature: (name: str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name.","title":"get_interpolator()"},{"location":"api/midgard-math/#interpolate","text":"Full name: midgard.math.interpolation.interpolate Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values.","title":"interpolate()"},{"location":"api/midgard-math/#interpolate_with_derivative","text":"Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, dx: float = 0.5, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives.","title":"interpolate_with_derivative()"},{"location":"api/midgard-math/#interpolated_univariate_spline","text":"Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function","title":"interpolated_univariate_spline()"},{"location":"api/midgard-math/#interpolators","text":"Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators.","title":"interpolators()"},{"location":"api/midgard-math/#lagrange","text":"Full name: midgard.math.interpolation.lagrange Signature: (x: numpy.ndarray, y: numpy.ndarray, *, window: int = 10, bounds_error: bool = True, assume_sorted: bool = False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function.","title":"lagrange()"},{"location":"api/midgard-math/#linear","text":"Full name: midgard.math.interpolation.linear Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function","title":"linear()"},{"location":"api/midgard-math/#register_interpolator","text":"Full name: midgard.math.interpolation.register_interpolator Signature: (func: Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function.","title":"register_interpolator()"},{"location":"api/midgard-math/#midgardmathlinear_regression","text":"Midgard library module for linear regression Description: The 'statsmodels' module is used for the linear regression. Outlier can be rejected beside normal linear regression analysis. Hereby a linear regression analysis is carried out, whereby a linear trend is estimated of the given data. The root-mean square (RMS) of the residuals (observation - linear trend) is used to detect outliers. As default the following outlier limit is defined: limit = outlier_limit_factor * RMS (with outlier_limit_factor=1.0) The 'outlier_limit_factor' can be chosen as argument by initialization of a LinearRegression class object. In addition the number of iteration for the outlier detection can be chosen with the argument 'outlier_iteration'. Example:","title":"midgard.math.linear_regression"},{"location":"api/midgard-math/#import-midgard-linearregression-class-of-linear_regression-module","text":"from midgard.math.linear_regression import LinearRegression","title":"Import Midgard LinearRegression class of linear_regression module"},{"location":"api/midgard-math/#generate-linearregression-object","text":"linreg = LinearRegression(x,y)","title":"Generate LinearRegression object"},{"location":"api/midgard-math/#get-solution","text":"interception = linreg.interception slope = linreg.slope","title":"Get solution"},{"location":"api/midgard-math/#linearregression","text":"Full name: midgard.math.linear_regression.LinearRegression Signature: (x: Union[numpy.ndarray, list], y: Union[numpy.ndarray, list], reject_outlier: bool = False, outlier_limit_factor: float = 1.0, outlier_iteration: int = 1) -> None Linear regression class Following arguments can be chosen by initialization of LinearRegression class objects: | Arguments | Type | Description | |:----------------------| :----------| :---------------------------------------------------------------------| | outlier_limit_factor | float | RMS of residuals are used for detecting outliers, whereby | | | | 'outlier_limit_factor' * 'RMS' is used as limit. As default is | | | | 'outlier_limit_factor' = 1.0 chosen. | | outlier_iteration | int | Number of iteration used to detect and reject outliers. Default is 1. | | reject_outlier | bool | Determine if outliers should be detected and rejected. Default is | | | | 'False', which means that no outliers are rejected. | | x | np.ndarray | X training data | | y | np.ndarray | Y target data |","title":"LinearRegression"},{"location":"api/midgard-math/#midgardmathnputil","text":"Utility wrapper for numpy functions Makes sure numpy functions can be called in a similar fashion for different use cases + both 1- and 2-dimensional input + both single values and arrays","title":"midgard.math.nputil"},{"location":"api/midgard-math/#hasharray","text":"Full name: midgard.math.nputil.HashArray Signature: (val)","title":"HashArray"},{"location":"api/midgard-math/#col","text":"Full name: midgard.math.nputil.col Signature: (vector)","title":"col()"},{"location":"api/midgard-math/#hashable","text":"Full name: midgard.math.nputil.hashable Signature: (func) Decorator for functions with numpy arrays as input arguments that will benefit from caching Example: from midgard.math import nputil from functools import lru_cache @nputil.hashable @lru_cache() def test_func(a: np.ndarray, b: np.ndarray = None) do_something return something","title":"hashable()"},{"location":"api/midgard-math/#norm","text":"Full name: midgard.math.nputil.norm Signature: (vector)","title":"norm()"},{"location":"api/midgard-math/#row","text":"Full name: midgard.math.nputil.row Signature: (vector)","title":"row()"},{"location":"api/midgard-math/#take","text":"Full name: midgard.math.nputil.take Signature: (vector, item)","title":"take()"},{"location":"api/midgard-math/#unit_vector","text":"Full name: midgard.math.nputil.unit_vector Signature: (vector)","title":"unit_vector()"},{"location":"api/midgard-math/#midgardmathplanetary_motion","text":"Midgard library for planetary motion Example: from migard.math import planetary_motion","title":"midgard.math.planetary_motion"},{"location":"api/midgard-math/#findsun","text":"Full name: midgard.math.planetary_motion.findsun Signature: (time: 'Time') -> numpy.ndarray Obtains the position vector of the Sun in relation to Earth (in ECEF). This routine is a reimplementation of routine findSun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Sun position vector given in ECEF [m]","title":"findsun()"},{"location":"api/midgard-math/#gsdtime_sun","text":"Full name: midgard.math.planetary_motion.gsdtime_sun Signature: (time: 'Time') -> Tuple[numpy.ndarray] Get position of the sun (low-precision) This routine is a reimplementation of routine GSDtime_sun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Tuple with following entries: Elements Description gstr GMST0 (to go from ECEF to inertial) [deg] slong Sun longitude [deg] sra Sun right Ascension [deg] sdec Sun declination in [deg]","title":"gsdtime_sun()"},{"location":"api/midgard-math/#midgardmathplate_motion","text":"Midgard library module for handling tectonic plate motion Description: Example: import numpy as np from midgard.math.plate_motion import PlateMotion pm = PlateMotion(plate=\"eura\") pos = np.array([2102928.189605, 721619.617278, 5958196.398820]) # in meter vel = pm.get_velocity(pos) # in mm/yr","title":"midgard.math.plate_motion"},{"location":"api/midgard-math/#platemotion","text":"Full name: midgard.math.plate_motion.PlateMotion Signature: (plate: str, model: str = 'itrf2014') -> None A class for handling of tectonic plate motion","title":"PlateMotion"},{"location":"api/midgard-math/#midgardmathrotation","text":"Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]])","title":"midgard.math.rotation"},{"location":"api/midgard-math/#r1","text":"Full name: midgard.math.rotation.R1 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R1()"},{"location":"api/midgard-math/#r2","text":"Full name: midgard.math.rotation.R2 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R2()"},{"location":"api/midgard-math/#r3","text":"Full name: midgard.math.rotation.R3 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R3()"},{"location":"api/midgard-math/#dr1","text":"Full name: midgard.math.rotation.dR1 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR1()"},{"location":"api/midgard-math/#dr2","text":"Full name: midgard.math.rotation.dR2 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR2()"},{"location":"api/midgard-math/#dr3","text":"Full name: midgard.math.rotation.dR3 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR3()"},{"location":"api/midgard-math/#enu2trs","text":"Full name: midgard.math.rotation.enu2trs Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"enu2trs()"},{"location":"api/midgard-math/#np_float-typevar","text":"np_float = ~np_float","title":"np_float (TypeVar)"},{"location":"api/midgard-math/#trs2enu","text":"Full name: midgard.math.rotation.trs2enu Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"trs2enu()"},{"location":"api/midgard-math/#midgardmathspatial_interpolation","text":"Methods for spatial interpolation in numpy arrays Description: Example: TODO","title":"midgard.math.spatial_interpolation"},{"location":"api/midgard-math/#interpolate_for_position","text":"Full name: midgard.math.spatial_interpolation.interpolate_for_position Signature: (grid_x: numpy.ndarray, grid_y: numpy.ndarray, values: numpy.ndarray, x: float, y: float, method: str = 'linear') -> float Interpolation in grid with size (n, m) for a given position Interpolation is based on scipy.interpolate.griddata module. More information about this module can be found under: https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html Args: grid_x : (n,m) Array with x-positions for each grid point grid_y : (n,m) Array with y-positions for each grid point values : (n,m) Array with data values for each grid point x : x-position y : y-position method : Method of interpolation: linear: tessellate the input point set to N-D simplices, and interpolate linearly on each simplex nearest: value of data point closest to the point of interpolation cubic: value determined from a piecewise cubic Returns: Interpolated value in data grid for a given position","title":"interpolate_for_position()"},{"location":"api/midgard-math/#midgardmathtransformation","text":"Midgard library module for handling of geodetic conversions Description:","title":"midgard.math.transformation"},{"location":"api/midgard-math/#delta_acr2trs_posvel","text":"Full name: midgard.math.transformation.delta_acr2trs_posvel Signature: (acr: 'AcrPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ACR to TRS","title":"delta_acr2trs_posvel()"},{"location":"api/midgard-math/#delta_enu2trs","text":"Full name: midgard.math.transformation.delta_enu2trs Signature: (enu: 'EnuPositionDelta') -> 'TrsPositionDelta' Convert position deltas from ENU to TRS","title":"delta_enu2trs()"},{"location":"api/midgard-math/#delta_enu2trs_posvel","text":"Full name: midgard.math.transformation.delta_enu2trs_posvel Signature: (enu: 'EnuPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ENU to TRS","title":"delta_enu2trs_posvel()"},{"location":"api/midgard-math/#delta_trs2acr_posvel","text":"Full name: midgard.math.transformation.delta_trs2acr_posvel Signature: (trs: 'TrsPosVelDelta') -> 'AcrPosVelDelta' Convert position deltas from TRS to ACR","title":"delta_trs2acr_posvel()"},{"location":"api/midgard-math/#delta_trs2enu","text":"Full name: midgard.math.transformation.delta_trs2enu Signature: (trs: 'TrsPositionDelta') -> 'EnuPositionDelta' Convert position deltas from TRS to ENU","title":"delta_trs2enu()"},{"location":"api/midgard-math/#delta_trs2enu_posvel","text":"Full name: midgard.math.transformation.delta_trs2enu_posvel Signature: (trs: 'TrsPosVelDelta') -> 'EnuPosVelDelta' Convert position deltas from TRS to ENU","title":"delta_trs2enu_posvel()"},{"location":"api/midgard-math/#kepler2trs","text":"Full name: midgard.math.transformation.kepler2trs Signature: (kepler: 'KeplerPosVel') -> 'TrsPosVel' Compute orbit position and velocity vector in geocentric equatorial coordinate system based on Keplerian elements for elliptic orbits. The implementation is based on Section 2.2.3 in :cite: montenbruck2012 .","title":"kepler2trs()"},{"location":"api/midgard-math/#llh2trs","text":"Full name: midgard.math.transformation.llh2trs Signature: (llh: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Reimplementation of GD2GCE.for from the IUA SOFA software collection.","title":"llh2trs()"},{"location":"api/midgard-math/#trs2kepler","text":"Full name: midgard.math.transformation.trs2kepler Signature: (trs: 'TrsPosVel') -> 'KeplerPosVel' Compute Keplerian elements for elliptic orbit based on orbit position and velocity vector given in ITRS. The used equations are described in Section 2.2.4 in Montenbruck :cite: montenbruck2012 . The position and velocity vector in ITRS and GM must be given in consistent units, which are [m], [m/s] and [m^3/s^2]. The resulting unit of the semimajor axis is implied by the unity of the position vector, i.e. [m]. .. note:: The function cannot be used with position/velocity vectors describing a circular or non-inclined orbit. Returns: tuple with numpy.ndarray types: Tuple with following Keplerian elements: =============== ====== ================================================================================== Keys Unit Description =============== ====== ================================================================================== a m Semimajor axis e Eccentricity of the orbit i rad Inclination Omega rad Right ascension of the ascending node omega rad Argument of perigee E rad Eccentric anomaly =============== ====== ==================================================================================","title":"trs2kepler()"},{"location":"api/midgard-math/#trs2llh","text":"Full name: midgard.math.transformation.trs2llh Signature: (trs: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Reimplementation of GC2GDE.for from the IUA SOFA software collection.","title":"trs2llh()"},{"location":"api/midgard-math/#midgardmathunit","text":"Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory.","title":"midgard.math.unit"},{"location":"api/midgard-math/#unit","text":"Full name: midgard.math.unit.Unit Signature: (from_unit: str, to_unit: Optional[str] = None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass.","title":"Unit"},{"location":"api/midgard-math/#np_float-typevar_1","text":"np_float = ~np_float","title":"np_float (TypeVar)"},{"location":"api/midgard-parsers/","text":"midgard.parsers Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser. names () Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers parse_file () Full name: midgard.parsers.parse_file Signature: (parser_name: str, file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, timer_logger: Optional[Callable[[str], NoneType]] = None, use_cache: bool = False, **parser_args: Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. (TODO: implement this) parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data midgard.parsers._parser Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() Parser Full name: midgard.parsers._parser.Parser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). midgard.parsers._parser_chain Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() ChainParser Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser . ParserDef Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker: Callable[[str, int, str], bool], label: Callable[[str, int], Any], parser_def: Dict[Any, Dict[str, Any]], skip_line: Optional[Callable[[str], bool]] = None, end_callback: Optional[Callable[[Dict[str, Any]], NoneType]] = None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten, whereby also regular expressions can be used (like '\\s+' for remove whitespaces. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group. midgard.parsers._parser_line Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() LineParser Full name: midgard.parsers._parser_line.LineParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser . midgard.parsers._parser_rinex Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format. RinexHeader Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker: str, fields: Dict[str, Tuple[int, int]], parser: Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields. RinexParser Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs . parser_cache () Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func: Callable[[ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions midgard.parsers._parser_sinex Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html SinexBlock Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker: str, fields: Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser: Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data. SinexField Full name: midgard.parsers._parser_sinex.SinexField Signature: (name: str, start_col: int, dtype: Optional[str], converter: Optional[str] = None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data. SinexParser Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed. parsing_factory () Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block. parsing_matrix_factory () Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker: str, size_marker: str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block. midgard.parsers.antex A parser for reading ANTEX format 1.4 data Example: from midgard import parsers # Parse data p = parsers.parse_file(parser_name='antex', file_path='igs14.atx') # Get dictionary with parsed data data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ). AntexParser Full name: midgard.parsers.antex.AntexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file. midgard.parsers.anubis A parser for reading Anubis xtr-files AnubisXtrParser Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Anubis XTR files midgard.parsers.api_water_level_norway A parser for reading water level data from open Norwegian water level API Example: from datetime import datetime from midgard import parsers # XML file with water level data exists p = parsers.parse_file(parser_name='api_water_level_norway', file_path='api_water_level_norway') data = p.as_dict() # Water level data has to be downloaded from API p = parsers.parse_file( parser_name='api_water_level_norway', file_path='api_water_level_norway', latitude=58.974339, longitude=5.730121, from_date=datetime(2021,11,21), to_date=datetime(2021,11,22), ) data = p.as_dict() Description: See https://api.sehavniva.no/tideapi_no.html for an example ApiWaterLevelNorwayParser Full name: midgard.parsers.api_water_level_norway.ApiWaterLevelNorwayParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, url: Optional[str] = None, latitude: Optional[float] = None, longitude: Optional[float] = None, from_date: Optional[datetime.datetime] = None, to_date: Optional[datetime.datetime] = None, reference_level: Optional[str] = 'chart_datum') -> None A parser for reading water level data from open Norwegian water level API See https://api.sehavniva.no/tideapi_no.html for an example Following data are available after water level data: Parameter Description flag Data flag (obs: observation, pre: prediction, weather: weather effect, forecast: forecast) time Observation water_level Water level in [cm] and meta -data: Key Description data_path File path parser_name Parser name url URL of water level API midgard.parsers.bcecmp_sisre A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR. BcecmpParser Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_with_dt_mean Satellite clock correction difference corrected for average satellite clock offset difference for given GNSS and epoch in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.bernese_clu A parser for reading Bernese CLU file Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_clu', file_path='NOR_NKG.CLU') data = p.as_dict() Description: Reads data from files in Bernese CLU format. BerneseCluParser Full name: midgard.parsers.bernese_clu.BerneseCluParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Bernese CLU file Following data are available after reading Bernese CLU file: Parameter Description station 4-digit station identifier domes Domes number cluster Cluster number and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.bernese_compar_out A parser for reading coordinate comparison in Bernese OUT format Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_compar_out', file_path='COMP211670.OUT') data = p.as_dict() Description: Reads coordinate comparison data from files in OUT format BerneseComparOutParser Full name: midgard.parsers.bernese_compar_out.BerneseComparOutParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading coordinate comparison in Bernese OUT format The parsed data are saved in variable data as a dictionay with 4-digit station name as key. The station related data are saved in a dictionary with following keys: Key Type Description coord_comp_east List[float] List with daily station coordinate comparison results for East component in [m] coord_comp_north List[float] List with daily station coordinate comparison results for North component in [m] coord_comp_up List[float] List with daily station coordinate comparison results for Up component in [m] coord_comp_rms_east float List with daily station coordinate comparison results for East component in [m] coord_comp_rms_north float List with daily station coordinate comparison results for North component in [m] coord_comp_rms_up float List with daily station coordinate comparison results for Up component in [m] pos_mean_x float X-coordinate of mean station coordinate position in [m] pos_mean_x_rms1 float RMS1 of X-coordinate of mean station coordinate position in [m] pos_mean_x_rms2 float RMS2 of X-coordinate of mean station coordinate position in [m] pos_mean_y float Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms1 float RMS1 of Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms2 float RMS2 of Y-coordinate of mean station coordinate position in [m] pos_mean_z float Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms1 float RMS1 of Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms2 float RMS2 of Z-coordinate of mean station coordinate position in [m] and meta -data: Key Description num_coord_files Number of coordinate files used for analysis time Date of analysis session __data_path__ File path __parser_name__ Parser name midgard.parsers.bernese_crd A parser for reading Bernese CRD file Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_crd', file_path='W20216.CRD') data = p.as_dict() Description: Reads data from files in Bernese CRD format. BerneseCrdParser Full name: midgard.parsers.bernese_crd.BerneseCrdParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Bernese CRD file Following data are available after reading Bernese CRD file: Parameter Description num Number of station coordinate solution station 4-digit station identifier domes Domes number gpssec Seconds of GPS week pos_x X-coordinate of station position pos_y Y-coordinate of station position pos_z Z-coordinate of station position flag Flag and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name midgard.parsers.bernese_prc A parser for reading protocol file in Bernese PRC format Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_prc', file_path='RES211670.PRC') data = p.as_dict() Description: Reads data from files in PRC format BernesePrcParser Full name: midgard.parsers.bernese_prc.BernesePrcParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading protocol file in Bernese PRC format The parsed data are saved in variable data as a dictionay with 4-digit station name as key. The station related data are saved in a dictionary with following keys: Key Type Description coord_comp_east List[float] List with daily station coordinate comparison results for East component in [m] coord_comp_north List[float] List with daily station coordinate comparison results for North component in [m] coord_comp_up List[float] List with daily station coordinate comparison results for Up component in [m] coord_comp_rms_east float List with daily station coordinate comparison results for East component in [m] coord_comp_rms_north float List with daily station coordinate comparison results for North component in [m] coord_comp_rms_up float List with daily station coordinate comparison results for Up component in [m] num_of_days float Number of days used for analysis pos_mean_x float X-coordinate of mean station coordinate position in [m] pos_mean_x_rms1 float RMS1 of X-coordinate of mean station coordinate position in [m] pos_mean_x_rms2 float RMS2 of X-coordinate of mean station coordinate position in [m] pos_mean_y float Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms1 float RMS1 of Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms2 float RMS2 of Y-coordinate of mean station coordinate position in [m] pos_mean_z float Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms1 float RMS1 of Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms2 float RMS2 of Z-coordinate of mean station coordinate position in [m] repeatability_east float Station coordinate repeatability for East component in [m] repeatability_north float Station coordinate repeatability for North component in [m] repeatability_up float Station coordinate repeatability for Up component in [m] residual_east float Station residuals for East component in [m] residual_north float Station residuals for North component in [m] residual_up float Station residuals for Up component in [m] and meta -data: Key Description num_coord_files Number of coordinate files used for analysis time Date of analysis session __data_path__ File path __parser_name__ Parser name midgard.parsers.bernese_sta A parser for reading station information in Bernese STA format Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_sta', file_path='NKG.STA') data = p.as_dict() Description: Reads station information from files in STA format, whereby at the moment only the 'STATION INFORMATION' part is parsed. BerneseStaParser Full name: midgard.parsers.bernese_sta.BerneseStaParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading station information in Bernese STA format The parsed data are saved in variable data as a dictionay with 4-digit station name as key and a list with station information dictionaries with following entries: Key Type Description antenna_serial_number str Antenna serial number antenna_serial_number_short str 6 last digits of antennna serial number antenna_type str Antenna type date_from datetime Start date where station information is valid date_to datetime End date of station information domes str Domes number description str Description normally with station name and country code eccentricity_east float East component of eccentricity in [m] eccentricity_north float North component of eccentricity in [m] eccentricity_up float Up component of eccentricity in [m] flag str Flag number radome str Antenna radome type receiver_serial_number str Receiver serial number receiver_serial_number_short str 6 last digits of receiver serial number receiver_type str Receiver type remark str Remark and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.bernese_trp A parser for reading troposphere files in Bernese TRP format Example: from analyx import parsers p = parsers.parse_file(parser_name='bernese_trp', file_path='F1_210300.TRP') data = p.as_dict() Description: Reads data from files troposphere files in TRP format BerneseTrpPaser Full name: midgard.parsers.bernese_trp.BerneseTrpPaser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading troposphere files in Bernese TRP format Following data can be available after reading troposphere files in Bernese TRP file: Key Description TODO and meta -data: Key Description TODO __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name midgard.parsers.cost A parser for reading COST format for ground-based GNSS delay and water vapour data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"cost\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the COST file format 2.2a (see :cite: cost ). CostParser Full name: midgard.parsers.cost.CostParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading COST datan file The parser reads ground-based GNSS delay and water vapour data in COST format version 2.2a. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). UNIT_DEF (dict) UNIT_DEF = {'height_geoid': UnitField(from_='meter', to_='meter'), 'humidity': UnitField(from_='', to_=''), 'iwv': UnitField(from_='kilogram/meter**2', to_='kilogram/meter**2'), 'pressure': UnitField(from_='hectopascal', to_='pascal'), 'temperature': UnitField(from_='kelvin', to_='kelvin'), 'trop_gradient_east': UnitField(from_='millimeter', to_='meter'), 'trop_gradient_east_sigma': UnitField(from_='millimeter', to_='meter'), 'trop_gradient_north': UnitField(from_='millimeter', to_='meter'), 'trop_gradient_north_sigma': UnitField(from_='millimeter', to_='meter'), 'trop_zenith_total': UnitField(from_='millimeter', to_='meter'), 'trop_zenith_total_sigma': UnitField(from_='millimeter', to_='meter'), 'trop_zenith_wet': UnitField(from_='millimeter', to_='meter')} UnitField Full name: midgard.parsers.cost.UnitField Signature: (from_=None, to_=None) A convenience class for defining a COST units of fields Args: from (str): Original field unit to (str): Destination field unit midgard.parsers.csv_ A parser for reading CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='csv_', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in CSV output format. The header information of the CSV file is not read (TODO). CsvParser Full name: midgard.parsers.csv_.CsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading CSV output files The CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the CSV colum values. Following meta -data are available after reading of CSV file: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.galileo_constellation_html A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example GalileoConstellationHTMLParser Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, url: Optional[str] = None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example midgard.parsers.gamit_org A parser for reading Gamit ORG files Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"gamit_org\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads the output file of Gamit. Example header from wich the time information is read from the .org file GLOBK Ver 5.34, Global solution Solution commenced with: 2022/ 6/22 0: 0 (2022.4712) Solution ended with : 2022/ 6/22 23:59 (2022.4740) Solution refers to : 2022/ 6/22 11:59 (2022.4726) [Seconds tag 45.000] Satellite IC epoch : 2022/ 6/22 12: 0 0.00 Example lines to be read from the .org file REYK_JPS X coordinate (m) 2587383.93370 -0.01703 0.00446 REYK_JPS Y coordinate (m) -1043033.57942 -0.04451 0.00404 REYK_JPS Z coordinate (m) 5716564.17515 0.00474 0.00947 GamitOrgParser Full name: midgard.parsers.gamit_org.GamitOrgParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading gamit org file Attributes: data (Dict): The (observation) data read from file. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataset() Return the parsed data as a Midgard Dataset parse() Parse data setup_parser() Set up information needed for the parser _parse_time() Parse a line of time information _parse_station() Parse a line of station information midgard.parsers.gipsy_stacov A parser for reading NASA JPL Gipsy stacov format file stacov format file includes Gipsy estimates and covariance information. Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_stacov', file_path='stacov_final') data = p.as_dict() Description: Reads data from files in Gipsy stacov format. GipsyStacovParser Full name: midgard.parsers.gipsy_stacov.GipsyStacovParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Gipsy stacov format file Following data are available after reading Gipsy stacov output file: Key Description correlation Correlation values correlation_index1 Correlation index (1st column) correlation_index2 Correlation index (2nd column) estimate Parameter estimate at the given time estimate_index Estimate index parameter Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. row Row number of correlations station Station name. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsy_sum A parser for reading Gipsy summary output file (*.sum) Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_sum', file_path='gipsy_sum') data = p.as_dict() Description: Reads data from files in Gipsy summary output format. GipsySummary Full name: midgard.parsers.gipsy_sum.GipsySummary Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Gipsy summary output file (*.sum) Gipsy summary file data are grouped as follows: Key Description date Processing date residual Dictionary with residual summary information station Station name residual entries are: Key Description code_obs_num Number of used pseudo-range observations code_outlier_num Number of rejected pseudo-range observations code_residual_rms RMS of residuals from used pseudo-range observations in [m] phase_obs_num Number of used phase observations phase_outlier_num Number of rejected phase observations phase_residual_rms RMS of residuals from used phase observations in [m] and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsy_tdp A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format. DatasetField Full name: midgard.parsers.gipsy_tdp.DatasetField Signature: (name=None, dtype=None) A convenience class for defining a dataset field properties Args: name (str): Dataset field name dtype (str): Dataset data type GipsyTdpParser Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_gdcov A parser for reading NASA JPL GipsyX gdcov format file gdcov format file includes GipsyX estimates and covariance information. NOTE: At the moment this parser can only read station estimate and covariance information, that means STA.X, STA.Y and STA.Z parameters. Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_gdcov', file_path='smoothFinal.gdcov') data = p.as_dict() Description: Reads data from files in GipsyX gdcov format. GipsyxGdcovParser Full name: midgard.parsers.gipsyx_gdcov.GipsyxGdcovParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX gdcov format file Following data are available after reading GipsyX gdcov output file: Key Description correlation Correlation values correlation_index1 Correlation index (1st column) correlation_index2 Correlation index (2nd column) estimate Parameter estimate at the given time estimate_index Estimate index parameter Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. row Row number of correlations station Station name. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_residual A parser for reading NASA JPL GipsyX residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_residual', file_path='finalResiduals.out') data = p.as_dict() Description: Reads data from files in GipsyX residual format. GipsyxResidualParser Full name: midgard.parsers.gipsyx_residual.GipsyxResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX residual file Following data are available after reading GipsyX residual output file: Key Description azimuth Azimuth from receiver azimuth_sat Azimuth from satellite data_type Data type (e.g. IonoFreeC_1P_2P, IonoFreeL_1P_2P) deleted Residuals are deleted, marked with True or False. elevation Elevation from receiver elevation_sat Elevation from satellite residual Post-fit residual satellite Satellite name station Station name time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_series A parser for reading NASA JPL GipsyX timeseries file Example: from analyx import parsers p = parsers.parse_file(parser_name='gipsyx_series', file_path='NYA1.series') data = p.as_dict() Description: Reads data from files in GipsyX timeseries format. GipsyxSeriesParser Full name: midgard.parsers.gipsyx_series.GipsyxSeriesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX timeseries file Following data are available after reading GipsyX residual output file: Key Description corr_en Correlation East-North. corr_ev Correlation East-Vertical. corr_nv Correlation North-Vertical. day Day decimalyear Date in unit year. east East coordinate in [m]. east_sigma Standard devication of east coordinate in [m]. hour Hour minute Minute month Month north North coordinate in [m]. north_sigma Standard devication of north coordinate in [m]. second Second time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. vertical Vertical coordinate in [m]. vertical_sigma Standard devication of vertical coordinate in [m]. year Year and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_summary A parser for reading GipsyX summary output file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_summary', file_path='gipsyx_summary') data = p.as_dict() Description: Reads data from files in GipsyX summary output format. GipsyxSummary Full name: midgard.parsers.gipsyx_summary.GipsyxSummary Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX summary file GipsyX summary file data are grouped as follows: Key Description position Dictionary with position summary information residual Dictionary with residual summary information station Station name position entries are: Key Description pos_x X-coordinate of station position solution pos_y Y-coordinate of station position solution pos_z Z-coordinate of station position solution pos_vs_ref_x X-coordinate of difference between solution and reference of station coordinate pos_vs_ref_y Y-coordinate of difference between solution and reference of station coordinate pos_vs_ref_z Z-coordinate of difference between solution and reference of station coordinate pos_vs_ref_e East-coordinate of difference between solution and reference of station coordinate pos_vs_ref_n North-coordinate of difference between solution and reference of station coordinate pos_vs_ref_v Vertical-coordinate of difference between solution and reference of station coordinate residual entries are: Key Description code_obs_num Number of used pseudo-range observations code_residual_max Maximal residual of used pseudo-range observations code_residual_min Minimal residual of used pseudo-range observations code_residual_rms RMS of residuals from used pseudo-range observations code_outlier_max Maximal residual of rejected pseudo-range observations code_outlier_min Minimal residual of rejected pseudo-range observations code_outlier_num Number of rejected pseudo-range observations code_outlier_rms RMS of residuals from rejected pseudo-range observations phase_obs_num Number of used phase observations phase_residual_min Minimal residual of used phase observations phase_residual_max Maximal residual of used phase observations phase_residual_rms RMS of residuals from used phase observations phase_outlier_max Maximal residual of rejected phase observations phase_outlier_min Minimal residual of rejected phase observations phase_outlier_num Number of rejected phase observations phase_outlier_rms RMS of residuals from rejected phase observations and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_tdp A parser for reading NASA JPL GipsyX time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in GipsyX time dependent parameter (TDP) format. DatasetField Full name: midgard.parsers.gipsyx_tdp.DatasetField Signature: (name=None, category=None, dtype=None) A convenience class for defining a dataset field properties Args: name (str): Dataset field name category (str): Category of parameter (e.g. station or satellite parameter) dtype (str): Dataset data type GipsyxTdpParser Full name: midgard.parsers.gipsyx_tdp.GipsyxTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX time dependent parameter (TDP) file Following data are available after reading GipsyX TDP output file: Key Description apriori Nominal value. This field contains the last value used by the model. name Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. value Parameter value at the given time and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.glab_output A parser for reading gLAB output files Example: from midgard import parsers p = parsers.parse_file(parser_name='glab_output', file_path='glab_output.txt') data = p.as_dict() Description: GlabOutputParser Full name: midgard.parsers.glab_output.GlabOutputParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading gLAB output files The keys of the data dictionary are defined depending, which kind of gLAB output file is read. The values of the data dictionary are represented by the gLAB colum values. Following meta -data are available after reading of gLAB files: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gnss_android_raw_data A parser for reading GNSS raw data from GnssLogger Android App Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"gnss_android_raw_data\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads raw data file from GnssLogger Android App. GnssAndroidRawDataParser Full name: midgard.parsers.gnss_android_raw_data.GnssAndroidRawDataParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None midgard.parsers.gnss_galat_results A parser for GALAT single point positioning result files Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_galat_results', file_path='galat_results.txt') data = p.as_dict() Description: Reads data from files in GALAT result format. GalatResults Full name: midgard.parsers.gnss_galat_results.GalatResults Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GALAT single point positioning result files Following data are available after reading GALAT SPP result file: Key Description time Time epoch latitude Latitude in degree longitude Longitude in degree height Height in [m] dlatitude Latitude related to reference coordinate in [m] dlongitude Longitude related to reference coordinate in [m] dheight Height related to reference coordinate in [m] hpe Horizontal positioning error (HPE) in [m] vpe Vertical positioning error (VPE) in [m] site_vel_3d 3D site velocity in [m/s] pdop Precision dilution of precision num_satellite_available Number of available satellites num_satellite_used Number of used satellites and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name midgard.parsers.gnssrefl_allrh A parser for reading GNSSREFL reflector height timeseries files Example: from midgard import parsers p = parsers.parse_file(parser_name='gnssrefl_allrh', file_path='tgde_allRH.txt') data = p.as_dict() Description: Reads data from files in GNSSREFL reflector height timeseries files GnssreflAllRh Full name: midgard.parsers.gnssrefl_allrh.GnssreflAllRh Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GNSSREFL reflector height timeseries files Following data are available after reading Terrapos residual file: Parameter Description amplitude Amplitude azimuth Azimuth in [deg] frequency GNSS frequency identifier peak2noise Peak to noise reflection_height Reflection height in [m] satellite Satellite number time Time as datetime object and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gravsoft_grid A parser for reading GRAVSOFT grid text files Description: GRAVSOFT grid data are stored rowwise from north to south. The grid values are initiated with label of latitude (lat) and longitude (lon) limits and spacing followed by the data section like: lat1 lat2 lon1 lon2 dlat dlon dn1 dn2 ... dnm ... ... d11 d12 ... d1m The grid label defines the exact latitude and longitude of the grid points with: lat1: west boundary of latitude lat2: east boundary of latitude lon1: west boundary of longitude lon2: east boundary of longitude dlat: latitude grid spacing dlon: longitude grid spacing The first data value in a grid file is thus the NW-corner (lat2, lon1) and the last the SE-corner (lat1, lon2). The number of points in a grid file is thus: num_lat = (lat2 - lat1)/dlat + 1 num_lon = (lon2 - lon1)/dlon + 1 Unknown data are shown by 9999. More information about the GRAVSOFT grid format can be found under: Forsberg, R. and Tscherning, C. C. (2014): \"An overview manual for the GRAVSOFT Geodetic Gravity Field Modelling Programs\", 3. edition, August 2014 Example: from midgard import parsers p = parsers.parse_file(parser_name=\"gravsoft_grid\", file_path=\"MeanSeaLevel1996-2014_above_Ellipsoid_EUREF89_v2021a.bin\") data = p.as_dict() GravsoftGrid Full name: midgard.parsers.gravsoft_grid.GravsoftGrid Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GRAVSOFT grid text files Following data are available after reading data: Parameter Description griddata Grid data with ordered grid blocks as list and meta -data: Key Description grid_increment_lat Latitude grid increment in degree grid_increment_lon Longitude grid increment in degree grid_lat_max Maximal latitude border limit of grid area in degree grid_lat_max Maximal latitude border limit of grid area in degree grid_lat_min Minimal latitude border limit of grid area in degree grid_lon_max Maximal longitude border limit of grid area in degree grid_lon_min Minimal longitude border limit of grid area in degree data_path File path parser_name Parser name midgard.parsers.rinex212_nav A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex212_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.12 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.12. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ). Rinex212NavParser Full name: midgard.parsers.rinex212_nav.Rinex212NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.12 (see :cite: rinex2 ). TODO: Would it not be better to use one leading underscore for non-public methods and instance variables. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale SYSNAMES (dict) SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}} SYSTEM_FILE_EXTENSION (dict) SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'} SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict) SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0} SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict) SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0} midgard.parsers.rinex2_nav A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.11 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.11. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ). Rinex2NavParser Full name: midgard.parsers.rinex2_nav.Rinex2NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.11 (see :cite: rinex2 ). TODO: Would it not be better to use one leading underscore for non-public methods and instance variables. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ion_alpha() Parse entries of RINEX header `ION ALPHA` to instance variable `meta`. _parse_ion_beta() Parse entries of RINEX header `ION BETA` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `DELTA-UTC: A0,A1,T,W` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale SYSNAMES (dict) SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}} SYSTEM_FILE_EXTENSION (dict) SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'} SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict) SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0} SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict) SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0} midgard.parsers.rinex2_obs A parser for reading Rinex data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the Rinex file format 2.11 (see :cite: rinex2 ). Rinex2Parser Full name: midgard.parsers.rinex2_obs.Rinex2Parser Signature: (*args: Tuple[Any], sampling_rate: Optional[float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 2.11 (see :cite: rinex2 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. system (String): GNSS identifier. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition. SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict) SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0} midgard.parsers.rinex3_nav A parser for reading GNSS RINEX v3.03 navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 3.03 (see :cite: rinex3 ). An exception is also, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. Rinex3NavParser Full name: midgard.parsers.rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 3.03 (see :cite: rinex3 ) except for GLONASS and SBAS. TODO: Would it not be better to use one leading underscore for non-public methods and instance variables. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale SYSNAMES (dict) SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}} SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict) SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'G': 0, 'I': 0, 'J': 0} SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict) SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'G': 0, 'I': 0, 'J': 0} midgard.parsers.rinex3_obs A parser for reading RINEX format 3.03 data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the RINEX file format version 3.03 (see :cite: rinex3 ). Rinex3Parser Full name: midgard.parsers.rinex3_obs.Rinex3Parser Signature: (*args: Tuple[Any], sampling_rate: Optional[float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 3.03 (see :cite: rinex3 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition. system (String): GNSS identifier. SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict) SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0} midgard.parsers.rinex_nav A parser for reading GNSS RINEX navigation files Example: from midgard.data import dataset from midgard import parsers # Parse data parser = parsers.parse(file_path=file_path) # Create a empty Dataset dset = data.Dataset() # Fill Dataset with parsed data parser.write_to_dataset(dset) Description: Reads GNSS ephemeris data from RINEX navigation file in format 2.11 (see :cite: rinex2 ) or 3.03 (see :cite: rinex3 ). get_rinex2_or_rinex3 () Full name: midgard.parsers.rinex_nav.get_rinex2_or_rinex3 Signature: (file_path: pathlib.PosixPath) -> 'TODO' Use either Rinex2NavParser or Rinex3NavParser for reading orbit files in format 2.11 or 3.03. Firstly the RINEX file version is read. Based on the read version number it is decided, which Parser should be used. Args: file_path (pathlib.PosixPath): File path to broadcast orbit file. midgard.parsers.sinex_discontinuities A parser for reading data from discontinuities.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='discontinuities_snx', file_path='discontinuities_snx') data = p.as_dict() Description: Reads discontinuities of GNSS station timeseries in SINEX format . DiscontinuitiesSnxParser Full name: midgard.parsers.sinex_discontinuities.DiscontinuitiesSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None A parser for reading data from discontinuties.snx file in SINEX format The solution discontinuity dictionary has as keys the site identifiers and as value the 'solution_discontinuity' entry. The dictionary has following strucuture: self.data[site] = { 'solution_discontinuity': [] } # SOLUTION/DISCONTINUITY SINEX block information with the 'solution_discontinuity' dictionary entries solution_discontinuity[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many discontinuities exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.sinex_events A parser for reading data from events.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='events_snx', file_path='events_snx') data = p.as_dict() Description: Reads events related to GNSS configuration, environment changes or station timeseries data problems in SINEX format . EventsSnxParser Full name: midgard.parsers.sinex_events.EventsSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None A parser for reading data from events.snx file in SINEX format The solution events dictionary has as keys the site identifiers and as value the 'solution_event' entry. The dictionary has following strucuture: self.data[site] = { 'solution_event': [] } # SOLUTION/EVENT SINEX block information with the 'solution_event' dictionary entries solution_event[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many events exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.sinex_site A parser for reading site related information from SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='sinex_site', file_path='sinex_site') data = p.as_dict() Description: Reads station related information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) from files in SINEX format. Following blocks are read: FILE/COMMENT SITE/ID SITE/RECEIVER SITE/ANTENNA SITE/ECCENTRICITY SOLUTION/EPOCHS SOLUTION/ESTIMATE Note, that FILE/COMMENT block is only used for reading reference frame information ('ref_frame'), which is added to SOLUTION/ESTIMATE dictionary. SinexSiteParser Full name: midgard.parsers.sinex_site.SinexSiteParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None A parser for reading site related information from SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id', 'site_receiver', 'solution_epoch' and 'solution_estimate'. The site dictionary has following structure: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information 'solution_epoch': [], # SOLUTION/EPOCH block information 'solution_estimate': [], # SOLUTION/ESTIMATE block information } with the site entry dictionary entries site_antenna[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'site_code': site_code, 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } solution_epochs[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_epoch': start_epoch, 'end_epoch': end_epoch, 'mean_epoch': mean_epoch } solution_estimate[ii] = { 'param_idx': param_idx, 'param_name': param_name, 'point_code': point_code, 'site_code': site_code, 'soln': soln, 'ref_epoch': ref_epoch, 'unit': unit, 'constraint': constraint, 'estimate': estimate, 'estimate_std': estimate_std, 'ref_frame': ref_frame } # Note: ref_frame taken from # FILE/COMMENT block, if exists. The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type, antenna monument and station coordinate changes were done at each site. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.sinex_tro A parser for reading troposphere results in SNX format Description: The implementation is based on example output files from Bernese. The SINEX_TRO format is an extension of the regular SINEX format, but mostly uses custom blocks. The following blocks are found in the example file: +FILE/REFERENCE (defined in SINEX 2.02) +TROP/DESCRIPTION (custom block) +TROP/STA_COORDINATES (custom block) +TROP/SOLUTION (custom block) The format of the custom blocks are derived by reading example files and blocks defined in the format that is not present in the example files are not implemented yet. Format description: https://files.igs.org/pub/data/format/sinex_tropo.txt BernTropSnxParser Full name: midgard.parsers.sinex_tro.BernTropSnxParser Signature: (file_path, encoding=None) A parser for reading data from Bernese troposphere files in SNX format midgard.parsers.slr_prediction A parser for reading SLR prediction files Description: Reads data from files in the CPF file format as defined in http://ilrs.gsfc.nasa.gov/docs/2006/cpf_1.01.pdf SlrPredictionParser Full name: midgard.parsers.slr_prediction.SlrPredictionParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading SLR prediction files (CPF format) midgard.parsers.spring_csv A parser for reading Spring CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='spring_csv', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in Spring CSV output format. The header information of the Spring CSV file is not read (TODO). SpringCsvParser Full name: midgard.parsers.spring_csv.SpringCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Spring CSV output files The Spring CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the Spring CSV colum values. Depending on the Spring CSV following dataset fields can be available: Field Description acquiredsat Number of acquired satellites (TODO?) gdop Geometric dilution of precision hdop Horizontal dilution of precision pdop Position (3D) dilution of precision satinview Number of satellites in view system GNSS identifier based on RINEX definition (e.g. G: GPS, E: Galileo) tdop Time dilution of precision time Observation time given as Time object usedsat Number of used satellites vdop Vertical dilution of precision ... ... midgard.parsers.ssc_site A parser for reading data from TRF files in SSC format Example: from midgard import parsers p = parsers.parse_file(parser_name='ssc_site', file_path='ssc_site') data = p.as_dict() Description: Reads station positions and velocities from TRF files in SSC format. The velocity model is a simple linear offset based on the reference epoch. SscSiteParser Full name: midgard.parsers.ssc_site.SscSiteParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading data from TRF files in SSC format midgard.parsers.terrapos_position A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format. TerraposPositionParser Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (*args: Tuple[Any], station: Optional[str] = None, **kwargs: Dict[Any, Any]) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.terrapos_residual A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format. TerraposResidualParser Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.ure_control_tool_csv A parser for reading URE Control Tool CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='ure_control_tool_csv', file_path='G_GAL258_E1E5a_URE-AllPRN_190301.csv') data = p.as_dict() Description: Reads data from files in URE Control Tool CSV output format. The header information of the URE Control Tool CSV file is not read (TODO). UreControlToolCsvParser Full name: midgard.parsers.ure_control_tool_csv.UreControlToolCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading URE Control Tool CSV output files The URE Control Tool CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the URE Control Tool CSV colum values. midgard.parsers.vlbi_source_names A parser for reading IVS source names translation table VlbiSourceNamesParser Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file midgard.parsers.wip_rinex A parser for reading Rinex files rinex () Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type midgard.parsers.wip_rinex2_nav A parser for reading RINEX navigation files with version 2.xx Rinex2NavParser Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 2.xx midgard.parsers.wip_rinex2_nav_header RINEX navigation header classes for file format version 2.xx Rinex2NavHeaderMixin Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx Rinex2NavHeaderParser Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex2_obs A parser for reading RINEX observation files with version 2.xx Rinex2ObsParser Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 2.xx midgard.parsers.wip_rinex2_obs_header RINEX observation header classes for file format version 3.xx Rinex2ObsHeaderMixin Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx Rinex2ObsHeaderParser Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex3_clk A parser for reading RINEX clock files with version 3.xx Rinex3ClkParser Full name: midgard.parsers.wip_rinex3_clk.Rinex3ClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX clock files with version 3.xx midgard.parsers.wip_rinex3_clk_header RINEX clock header classes for file format version 3.xx Rinex3ClkHeaderMixin Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx Rinex3ClkHeaderParser Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex3_nav A parser for reading RINEX navigation files with version 3.xx Rinex3NavParser Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 3.xx midgard.parsers.wip_rinex3_nav_header RINEX navigation header classes for file format version 3.xx Rinex3NavHeaderMixin Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx Rinex3NavHeaderParser Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex3_obs A parser for reading RINEX observation files with version 3.xx Rinex3ObsParser Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 3.xx midgard.parsers.wip_rinex3_obs_header RINEX observation header classes for file format version 3.xx Rinex3ObsHeaderMixin Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx Rinex3ObsHeaderParser Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex_clk A parser for reading Rinex navigation files RinexClkParser Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None Class for defining common methods for RINEX clock parsers. rinex_clk () Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_nav A parser for reading Rinex navigation files RinexNavParser Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None Class for defining common methods for RINEX navigation parsers. rinex_nav () Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_obs A parser for reading Rinex observation files RinexObsParser Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None Class for defining common methods for RINEX observation parsers. rinex_obs () Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"midgard.parsers"},{"location":"api/midgard-parsers/#midgardparsers","text":"Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser.","title":"midgard.parsers"},{"location":"api/midgard-parsers/#names","text":"Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers","title":"names()"},{"location":"api/midgard-parsers/#parse_file","text":"Full name: midgard.parsers.parse_file Signature: (parser_name: str, file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, timer_logger: Optional[Callable[[str], NoneType]] = None, use_cache: bool = False, **parser_args: Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. (TODO: implement this) parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data","title":"parse_file()"},{"location":"api/midgard-parsers/#midgardparsers_parser","text":"Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser"},{"location":"api/midgard-parsers/#parser","text":"Full name: midgard.parsers._parser.Parser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...).","title":"Parser"},{"location":"api/midgard-parsers/#midgardparsers_parser_chain","text":"Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_chain"},{"location":"api/midgard-parsers/#chainparser","text":"Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"ChainParser"},{"location":"api/midgard-parsers/#parserdef","text":"Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker: Callable[[str, int, str], bool], label: Callable[[str, int], Any], parser_def: Dict[Any, Dict[str, Any]], skip_line: Optional[Callable[[str], bool]] = None, end_callback: Optional[Callable[[Dict[str, Any]], NoneType]] = None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten, whereby also regular expressions can be used (like '\\s+' for remove whitespaces. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group.","title":"ParserDef"},{"location":"api/midgard-parsers/#midgardparsers_parser_line","text":"Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_line"},{"location":"api/midgard-parsers/#lineparser","text":"Full name: midgard.parsers._parser_line.LineParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"LineParser"},{"location":"api/midgard-parsers/#midgardparsers_parser_rinex","text":"Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format.","title":"midgard.parsers._parser_rinex"},{"location":"api/midgard-parsers/#rinexheader","text":"Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker: str, fields: Dict[str, Tuple[int, int]], parser: Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields.","title":"RinexHeader"},{"location":"api/midgard-parsers/#rinexparser","text":"Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs .","title":"RinexParser"},{"location":"api/midgard-parsers/#parser_cache","text":"Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func: Callable[[ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions","title":"parser_cache()"},{"location":"api/midgard-parsers/#midgardparsers_parser_sinex","text":"Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html","title":"midgard.parsers._parser_sinex"},{"location":"api/midgard-parsers/#sinexblock","text":"Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker: str, fields: Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser: Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data.","title":"SinexBlock"},{"location":"api/midgard-parsers/#sinexfield","text":"Full name: midgard.parsers._parser_sinex.SinexField Signature: (name: str, start_col: int, dtype: Optional[str], converter: Optional[str] = None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data.","title":"SinexField"},{"location":"api/midgard-parsers/#sinexparser","text":"Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed.","title":"SinexParser"},{"location":"api/midgard-parsers/#parsing_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block.","title":"parsing_factory()"},{"location":"api/midgard-parsers/#parsing_matrix_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker: str, size_marker: str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block.","title":"parsing_matrix_factory()"},{"location":"api/midgard-parsers/#midgardparsersantex","text":"A parser for reading ANTEX format 1.4 data Example: from midgard import parsers # Parse data p = parsers.parse_file(parser_name='antex', file_path='igs14.atx') # Get dictionary with parsed data data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ).","title":"midgard.parsers.antex"},{"location":"api/midgard-parsers/#antexparser","text":"Full name: midgard.parsers.antex.AntexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file.","title":"AntexParser"},{"location":"api/midgard-parsers/#midgardparsersanubis","text":"A parser for reading Anubis xtr-files","title":"midgard.parsers.anubis"},{"location":"api/midgard-parsers/#anubisxtrparser","text":"Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Anubis XTR files","title":"AnubisXtrParser"},{"location":"api/midgard-parsers/#midgardparsersapi_water_level_norway","text":"A parser for reading water level data from open Norwegian water level API Example: from datetime import datetime from midgard import parsers # XML file with water level data exists p = parsers.parse_file(parser_name='api_water_level_norway', file_path='api_water_level_norway') data = p.as_dict() # Water level data has to be downloaded from API p = parsers.parse_file( parser_name='api_water_level_norway', file_path='api_water_level_norway', latitude=58.974339, longitude=5.730121, from_date=datetime(2021,11,21), to_date=datetime(2021,11,22), ) data = p.as_dict() Description: See https://api.sehavniva.no/tideapi_no.html for an example","title":"midgard.parsers.api_water_level_norway"},{"location":"api/midgard-parsers/#apiwaterlevelnorwayparser","text":"Full name: midgard.parsers.api_water_level_norway.ApiWaterLevelNorwayParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, url: Optional[str] = None, latitude: Optional[float] = None, longitude: Optional[float] = None, from_date: Optional[datetime.datetime] = None, to_date: Optional[datetime.datetime] = None, reference_level: Optional[str] = 'chart_datum') -> None A parser for reading water level data from open Norwegian water level API See https://api.sehavniva.no/tideapi_no.html for an example Following data are available after water level data: Parameter Description flag Data flag (obs: observation, pre: prediction, weather: weather effect, forecast: forecast) time Observation water_level Water level in [cm] and meta -data: Key Description data_path File path parser_name Parser name url URL of water level API","title":"ApiWaterLevelNorwayParser"},{"location":"api/midgard-parsers/#midgardparsersbcecmp_sisre","text":"A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR.","title":"midgard.parsers.bcecmp_sisre"},{"location":"api/midgard-parsers/#bcecmpparser","text":"Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_with_dt_mean Satellite clock correction difference corrected for average satellite clock offset difference for given GNSS and epoch in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"BcecmpParser"},{"location":"api/midgard-parsers/#midgardparsersbernese_clu","text":"A parser for reading Bernese CLU file Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_clu', file_path='NOR_NKG.CLU') data = p.as_dict() Description: Reads data from files in Bernese CLU format.","title":"midgard.parsers.bernese_clu"},{"location":"api/midgard-parsers/#bernesecluparser","text":"Full name: midgard.parsers.bernese_clu.BerneseCluParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Bernese CLU file Following data are available after reading Bernese CLU file: Parameter Description station 4-digit station identifier domes Domes number cluster Cluster number and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"BerneseCluParser"},{"location":"api/midgard-parsers/#midgardparsersbernese_compar_out","text":"A parser for reading coordinate comparison in Bernese OUT format Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_compar_out', file_path='COMP211670.OUT') data = p.as_dict() Description: Reads coordinate comparison data from files in OUT format","title":"midgard.parsers.bernese_compar_out"},{"location":"api/midgard-parsers/#bernesecomparoutparser","text":"Full name: midgard.parsers.bernese_compar_out.BerneseComparOutParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading coordinate comparison in Bernese OUT format The parsed data are saved in variable data as a dictionay with 4-digit station name as key. The station related data are saved in a dictionary with following keys: Key Type Description coord_comp_east List[float] List with daily station coordinate comparison results for East component in [m] coord_comp_north List[float] List with daily station coordinate comparison results for North component in [m] coord_comp_up List[float] List with daily station coordinate comparison results for Up component in [m] coord_comp_rms_east float List with daily station coordinate comparison results for East component in [m] coord_comp_rms_north float List with daily station coordinate comparison results for North component in [m] coord_comp_rms_up float List with daily station coordinate comparison results for Up component in [m] pos_mean_x float X-coordinate of mean station coordinate position in [m] pos_mean_x_rms1 float RMS1 of X-coordinate of mean station coordinate position in [m] pos_mean_x_rms2 float RMS2 of X-coordinate of mean station coordinate position in [m] pos_mean_y float Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms1 float RMS1 of Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms2 float RMS2 of Y-coordinate of mean station coordinate position in [m] pos_mean_z float Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms1 float RMS1 of Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms2 float RMS2 of Z-coordinate of mean station coordinate position in [m] and meta -data: Key Description num_coord_files Number of coordinate files used for analysis time Date of analysis session __data_path__ File path __parser_name__ Parser name","title":"BerneseComparOutParser"},{"location":"api/midgard-parsers/#midgardparsersbernese_crd","text":"A parser for reading Bernese CRD file Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_crd', file_path='W20216.CRD') data = p.as_dict() Description: Reads data from files in Bernese CRD format.","title":"midgard.parsers.bernese_crd"},{"location":"api/midgard-parsers/#bernesecrdparser","text":"Full name: midgard.parsers.bernese_crd.BerneseCrdParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Bernese CRD file Following data are available after reading Bernese CRD file: Parameter Description num Number of station coordinate solution station 4-digit station identifier domes Domes number gpssec Seconds of GPS week pos_x X-coordinate of station position pos_y Y-coordinate of station position pos_z Z-coordinate of station position flag Flag and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name","title":"BerneseCrdParser"},{"location":"api/midgard-parsers/#midgardparsersbernese_prc","text":"A parser for reading protocol file in Bernese PRC format Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_prc', file_path='RES211670.PRC') data = p.as_dict() Description: Reads data from files in PRC format","title":"midgard.parsers.bernese_prc"},{"location":"api/midgard-parsers/#berneseprcparser","text":"Full name: midgard.parsers.bernese_prc.BernesePrcParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading protocol file in Bernese PRC format The parsed data are saved in variable data as a dictionay with 4-digit station name as key. The station related data are saved in a dictionary with following keys: Key Type Description coord_comp_east List[float] List with daily station coordinate comparison results for East component in [m] coord_comp_north List[float] List with daily station coordinate comparison results for North component in [m] coord_comp_up List[float] List with daily station coordinate comparison results for Up component in [m] coord_comp_rms_east float List with daily station coordinate comparison results for East component in [m] coord_comp_rms_north float List with daily station coordinate comparison results for North component in [m] coord_comp_rms_up float List with daily station coordinate comparison results for Up component in [m] num_of_days float Number of days used for analysis pos_mean_x float X-coordinate of mean station coordinate position in [m] pos_mean_x_rms1 float RMS1 of X-coordinate of mean station coordinate position in [m] pos_mean_x_rms2 float RMS2 of X-coordinate of mean station coordinate position in [m] pos_mean_y float Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms1 float RMS1 of Y-coordinate of mean station coordinate position in [m] pos_mean_y_rms2 float RMS2 of Y-coordinate of mean station coordinate position in [m] pos_mean_z float Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms1 float RMS1 of Z-coordinate of mean station coordinate position in [m] pos_mean_z_rms2 float RMS2 of Z-coordinate of mean station coordinate position in [m] repeatability_east float Station coordinate repeatability for East component in [m] repeatability_north float Station coordinate repeatability for North component in [m] repeatability_up float Station coordinate repeatability for Up component in [m] residual_east float Station residuals for East component in [m] residual_north float Station residuals for North component in [m] residual_up float Station residuals for Up component in [m] and meta -data: Key Description num_coord_files Number of coordinate files used for analysis time Date of analysis session __data_path__ File path __parser_name__ Parser name","title":"BernesePrcParser"},{"location":"api/midgard-parsers/#midgardparsersbernese_sta","text":"A parser for reading station information in Bernese STA format Example: from midgard import parsers p = parsers.parse_file(parser_name='bernese_sta', file_path='NKG.STA') data = p.as_dict() Description: Reads station information from files in STA format, whereby at the moment only the 'STATION INFORMATION' part is parsed.","title":"midgard.parsers.bernese_sta"},{"location":"api/midgard-parsers/#bernesestaparser","text":"Full name: midgard.parsers.bernese_sta.BerneseStaParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading station information in Bernese STA format The parsed data are saved in variable data as a dictionay with 4-digit station name as key and a list with station information dictionaries with following entries: Key Type Description antenna_serial_number str Antenna serial number antenna_serial_number_short str 6 last digits of antennna serial number antenna_type str Antenna type date_from datetime Start date where station information is valid date_to datetime End date of station information domes str Domes number description str Description normally with station name and country code eccentricity_east float East component of eccentricity in [m] eccentricity_north float North component of eccentricity in [m] eccentricity_up float Up component of eccentricity in [m] flag str Flag number radome str Antenna radome type receiver_serial_number str Receiver serial number receiver_serial_number_short str 6 last digits of receiver serial number receiver_type str Receiver type remark str Remark and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"BerneseStaParser"},{"location":"api/midgard-parsers/#midgardparsersbernese_trp","text":"A parser for reading troposphere files in Bernese TRP format Example: from analyx import parsers p = parsers.parse_file(parser_name='bernese_trp', file_path='F1_210300.TRP') data = p.as_dict() Description: Reads data from files troposphere files in TRP format","title":"midgard.parsers.bernese_trp"},{"location":"api/midgard-parsers/#bernesetrppaser","text":"Full name: midgard.parsers.bernese_trp.BerneseTrpPaser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading troposphere files in Bernese TRP format Following data can be available after reading troposphere files in Bernese TRP file: Key Description TODO and meta -data: Key Description TODO __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name","title":"BerneseTrpPaser"},{"location":"api/midgard-parsers/#midgardparserscost","text":"A parser for reading COST format for ground-based GNSS delay and water vapour data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"cost\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the COST file format 2.2a (see :cite: cost ).","title":"midgard.parsers.cost"},{"location":"api/midgard-parsers/#costparser","text":"Full name: midgard.parsers.cost.CostParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading COST datan file The parser reads ground-based GNSS delay and water vapour data in COST format version 2.2a. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...).","title":"CostParser"},{"location":"api/midgard-parsers/#unit_def-dict","text":"UNIT_DEF = {'height_geoid': UnitField(from_='meter', to_='meter'), 'humidity': UnitField(from_='', to_=''), 'iwv': UnitField(from_='kilogram/meter**2', to_='kilogram/meter**2'), 'pressure': UnitField(from_='hectopascal', to_='pascal'), 'temperature': UnitField(from_='kelvin', to_='kelvin'), 'trop_gradient_east': UnitField(from_='millimeter', to_='meter'), 'trop_gradient_east_sigma': UnitField(from_='millimeter', to_='meter'), 'trop_gradient_north': UnitField(from_='millimeter', to_='meter'), 'trop_gradient_north_sigma': UnitField(from_='millimeter', to_='meter'), 'trop_zenith_total': UnitField(from_='millimeter', to_='meter'), 'trop_zenith_total_sigma': UnitField(from_='millimeter', to_='meter'), 'trop_zenith_wet': UnitField(from_='millimeter', to_='meter')}","title":"UNIT_DEF (dict)"},{"location":"api/midgard-parsers/#unitfield","text":"Full name: midgard.parsers.cost.UnitField Signature: (from_=None, to_=None) A convenience class for defining a COST units of fields Args: from (str): Original field unit to (str): Destination field unit","title":"UnitField"},{"location":"api/midgard-parsers/#midgardparserscsv_","text":"A parser for reading CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='csv_', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in CSV output format. The header information of the CSV file is not read (TODO).","title":"midgard.parsers.csv_"},{"location":"api/midgard-parsers/#csvparser","text":"Full name: midgard.parsers.csv_.CsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading CSV output files The CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the CSV colum values. Following meta -data are available after reading of CSV file: Key Description __data_path__ File path __parser_name__ Parser name","title":"CsvParser"},{"location":"api/midgard-parsers/#midgardparsersgalileo_constellation_html","text":"A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"midgard.parsers.galileo_constellation_html"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparser","text":"Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, url: Optional[str] = None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"GalileoConstellationHTMLParser"},{"location":"api/midgard-parsers/#midgardparsersgamit_org","text":"A parser for reading Gamit ORG files Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"gamit_org\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads the output file of Gamit. Example header from wich the time information is read from the .org file","title":"midgard.parsers.gamit_org"},{"location":"api/midgard-parsers/#globk-ver-534-global-solution","text":"Solution commenced with: 2022/ 6/22 0: 0 (2022.4712) Solution ended with : 2022/ 6/22 23:59 (2022.4740) Solution refers to : 2022/ 6/22 11:59 (2022.4726) [Seconds tag 45.000] Satellite IC epoch : 2022/ 6/22 12: 0 0.00 Example lines to be read from the .org file REYK_JPS X coordinate (m) 2587383.93370 -0.01703 0.00446 REYK_JPS Y coordinate (m) -1043033.57942 -0.04451 0.00404 REYK_JPS Z coordinate (m) 5716564.17515 0.00474 0.00947","title":"GLOBK Ver 5.34, Global solution"},{"location":"api/midgard-parsers/#gamitorgparser","text":"Full name: midgard.parsers.gamit_org.GamitOrgParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading gamit org file Attributes: data (Dict): The (observation) data read from file. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataset() Return the parsed data as a Midgard Dataset parse() Parse data setup_parser() Set up information needed for the parser _parse_time() Parse a line of time information _parse_station() Parse a line of station information","title":"GamitOrgParser"},{"location":"api/midgard-parsers/#midgardparsersgipsy_stacov","text":"A parser for reading NASA JPL Gipsy stacov format file stacov format file includes Gipsy estimates and covariance information. Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_stacov', file_path='stacov_final') data = p.as_dict() Description: Reads data from files in Gipsy stacov format.","title":"midgard.parsers.gipsy_stacov"},{"location":"api/midgard-parsers/#gipsystacovparser","text":"Full name: midgard.parsers.gipsy_stacov.GipsyStacovParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Gipsy stacov format file Following data are available after reading Gipsy stacov output file: Key Description correlation Correlation values correlation_index1 Correlation index (1st column) correlation_index2 Correlation index (2nd column) estimate Parameter estimate at the given time estimate_index Estimate index parameter Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. row Row number of correlations station Station name. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyStacovParser"},{"location":"api/midgard-parsers/#midgardparsersgipsy_sum","text":"A parser for reading Gipsy summary output file (*.sum) Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_sum', file_path='gipsy_sum') data = p.as_dict() Description: Reads data from files in Gipsy summary output format.","title":"midgard.parsers.gipsy_sum"},{"location":"api/midgard-parsers/#gipsysummary","text":"Full name: midgard.parsers.gipsy_sum.GipsySummary Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Gipsy summary output file (*.sum) Gipsy summary file data are grouped as follows: Key Description date Processing date residual Dictionary with residual summary information station Station name residual entries are: Key Description code_obs_num Number of used pseudo-range observations code_outlier_num Number of rejected pseudo-range observations code_residual_rms RMS of residuals from used pseudo-range observations in [m] phase_obs_num Number of used phase observations phase_outlier_num Number of rejected phase observations phase_residual_rms RMS of residuals from used phase observations in [m] and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsySummary"},{"location":"api/midgard-parsers/#midgardparsersgipsy_tdp","text":"A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format.","title":"midgard.parsers.gipsy_tdp"},{"location":"api/midgard-parsers/#datasetfield","text":"Full name: midgard.parsers.gipsy_tdp.DatasetField Signature: (name=None, dtype=None) A convenience class for defining a dataset field properties Args: name (str): Dataset field name dtype (str): Dataset data type","title":"DatasetField"},{"location":"api/midgard-parsers/#gipsytdpparser","text":"Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyTdpParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_gdcov","text":"A parser for reading NASA JPL GipsyX gdcov format file gdcov format file includes GipsyX estimates and covariance information. NOTE: At the moment this parser can only read station estimate and covariance information, that means STA.X, STA.Y and STA.Z parameters. Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_gdcov', file_path='smoothFinal.gdcov') data = p.as_dict() Description: Reads data from files in GipsyX gdcov format.","title":"midgard.parsers.gipsyx_gdcov"},{"location":"api/midgard-parsers/#gipsyxgdcovparser","text":"Full name: midgard.parsers.gipsyx_gdcov.GipsyxGdcovParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX gdcov format file Following data are available after reading GipsyX gdcov output file: Key Description correlation Correlation values correlation_index1 Correlation index (1st column) correlation_index2 Correlation index (2nd column) estimate Parameter estimate at the given time estimate_index Estimate index parameter Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. row Row number of correlations station Station name. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxGdcovParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_residual","text":"A parser for reading NASA JPL GipsyX residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_residual', file_path='finalResiduals.out') data = p.as_dict() Description: Reads data from files in GipsyX residual format.","title":"midgard.parsers.gipsyx_residual"},{"location":"api/midgard-parsers/#gipsyxresidualparser","text":"Full name: midgard.parsers.gipsyx_residual.GipsyxResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX residual file Following data are available after reading GipsyX residual output file: Key Description azimuth Azimuth from receiver azimuth_sat Azimuth from satellite data_type Data type (e.g. IonoFreeC_1P_2P, IonoFreeL_1P_2P) deleted Residuals are deleted, marked with True or False. elevation Elevation from receiver elevation_sat Elevation from satellite residual Post-fit residual satellite Satellite name station Station name time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxResidualParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_series","text":"A parser for reading NASA JPL GipsyX timeseries file Example: from analyx import parsers p = parsers.parse_file(parser_name='gipsyx_series', file_path='NYA1.series') data = p.as_dict() Description: Reads data from files in GipsyX timeseries format.","title":"midgard.parsers.gipsyx_series"},{"location":"api/midgard-parsers/#gipsyxseriesparser","text":"Full name: midgard.parsers.gipsyx_series.GipsyxSeriesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX timeseries file Following data are available after reading GipsyX residual output file: Key Description corr_en Correlation East-North. corr_ev Correlation East-Vertical. corr_nv Correlation North-Vertical. day Day decimalyear Date in unit year. east East coordinate in [m]. east_sigma Standard devication of east coordinate in [m]. hour Hour minute Minute month Month north North coordinate in [m]. north_sigma Standard devication of north coordinate in [m]. second Second time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. vertical Vertical coordinate in [m]. vertical_sigma Standard devication of vertical coordinate in [m]. year Year and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxSeriesParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_summary","text":"A parser for reading GipsyX summary output file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_summary', file_path='gipsyx_summary') data = p.as_dict() Description: Reads data from files in GipsyX summary output format.","title":"midgard.parsers.gipsyx_summary"},{"location":"api/midgard-parsers/#gipsyxsummary","text":"Full name: midgard.parsers.gipsyx_summary.GipsyxSummary Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX summary file GipsyX summary file data are grouped as follows: Key Description position Dictionary with position summary information residual Dictionary with residual summary information station Station name position entries are: Key Description pos_x X-coordinate of station position solution pos_y Y-coordinate of station position solution pos_z Z-coordinate of station position solution pos_vs_ref_x X-coordinate of difference between solution and reference of station coordinate pos_vs_ref_y Y-coordinate of difference between solution and reference of station coordinate pos_vs_ref_z Z-coordinate of difference between solution and reference of station coordinate pos_vs_ref_e East-coordinate of difference between solution and reference of station coordinate pos_vs_ref_n North-coordinate of difference between solution and reference of station coordinate pos_vs_ref_v Vertical-coordinate of difference between solution and reference of station coordinate residual entries are: Key Description code_obs_num Number of used pseudo-range observations code_residual_max Maximal residual of used pseudo-range observations code_residual_min Minimal residual of used pseudo-range observations code_residual_rms RMS of residuals from used pseudo-range observations code_outlier_max Maximal residual of rejected pseudo-range observations code_outlier_min Minimal residual of rejected pseudo-range observations code_outlier_num Number of rejected pseudo-range observations code_outlier_rms RMS of residuals from rejected pseudo-range observations phase_obs_num Number of used phase observations phase_residual_min Minimal residual of used phase observations phase_residual_max Maximal residual of used phase observations phase_residual_rms RMS of residuals from used phase observations phase_outlier_max Maximal residual of rejected phase observations phase_outlier_min Minimal residual of rejected phase observations phase_outlier_num Number of rejected phase observations phase_outlier_rms RMS of residuals from rejected phase observations and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxSummary"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_tdp","text":"A parser for reading NASA JPL GipsyX time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in GipsyX time dependent parameter (TDP) format.","title":"midgard.parsers.gipsyx_tdp"},{"location":"api/midgard-parsers/#datasetfield_1","text":"Full name: midgard.parsers.gipsyx_tdp.DatasetField Signature: (name=None, category=None, dtype=None) A convenience class for defining a dataset field properties Args: name (str): Dataset field name category (str): Category of parameter (e.g. station or satellite parameter) dtype (str): Dataset data type","title":"DatasetField"},{"location":"api/midgard-parsers/#gipsyxtdpparser","text":"Full name: midgard.parsers.gipsyx_tdp.GipsyxTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GipsyX time dependent parameter (TDP) file Following data are available after reading GipsyX TDP output file: Key Description apriori Nominal value. This field contains the last value used by the model. name Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. value Parameter value at the given time and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxTdpParser"},{"location":"api/midgard-parsers/#midgardparsersglab_output","text":"A parser for reading gLAB output files Example: from midgard import parsers p = parsers.parse_file(parser_name='glab_output', file_path='glab_output.txt') data = p.as_dict() Description:","title":"midgard.parsers.glab_output"},{"location":"api/midgard-parsers/#glaboutputparser","text":"Full name: midgard.parsers.glab_output.GlabOutputParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading gLAB output files The keys of the data dictionary are defined depending, which kind of gLAB output file is read. The values of the data dictionary are represented by the gLAB colum values. Following meta -data are available after reading of gLAB files: Key Description __data_path__ File path __parser_name__ Parser name","title":"GlabOutputParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_android_raw_data","text":"A parser for reading GNSS raw data from GnssLogger Android App Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"gnss_android_raw_data\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads raw data file from GnssLogger Android App.","title":"midgard.parsers.gnss_android_raw_data"},{"location":"api/midgard-parsers/#gnssandroidrawdataparser","text":"Full name: midgard.parsers.gnss_android_raw_data.GnssAndroidRawDataParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None","title":"GnssAndroidRawDataParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_galat_results","text":"A parser for GALAT single point positioning result files Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_galat_results', file_path='galat_results.txt') data = p.as_dict() Description: Reads data from files in GALAT result format.","title":"midgard.parsers.gnss_galat_results"},{"location":"api/midgard-parsers/#galatresults","text":"Full name: midgard.parsers.gnss_galat_results.GalatResults Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GALAT single point positioning result files Following data are available after reading GALAT SPP result file: Key Description time Time epoch latitude Latitude in degree longitude Longitude in degree height Height in [m] dlatitude Latitude related to reference coordinate in [m] dlongitude Longitude related to reference coordinate in [m] dheight Height related to reference coordinate in [m] hpe Horizontal positioning error (HPE) in [m] vpe Vertical positioning error (VPE) in [m] site_vel_3d 3D site velocity in [m/s] pdop Precision dilution of precision num_satellite_available Number of available satellites num_satellite_used Number of used satellites and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name","title":"GalatResults"},{"location":"api/midgard-parsers/#midgardparsersgnssrefl_allrh","text":"A parser for reading GNSSREFL reflector height timeseries files Example: from midgard import parsers p = parsers.parse_file(parser_name='gnssrefl_allrh', file_path='tgde_allRH.txt') data = p.as_dict() Description: Reads data from files in GNSSREFL reflector height timeseries files","title":"midgard.parsers.gnssrefl_allrh"},{"location":"api/midgard-parsers/#gnssreflallrh","text":"Full name: midgard.parsers.gnssrefl_allrh.GnssreflAllRh Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GNSSREFL reflector height timeseries files Following data are available after reading Terrapos residual file: Parameter Description amplitude Amplitude azimuth Azimuth in [deg] frequency GNSS frequency identifier peak2noise Peak to noise reflection_height Reflection height in [m] satellite Satellite number time Time as datetime object and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GnssreflAllRh"},{"location":"api/midgard-parsers/#midgardparsersgravsoft_grid","text":"A parser for reading GRAVSOFT grid text files Description: GRAVSOFT grid data are stored rowwise from north to south. The grid values are initiated with label of latitude (lat) and longitude (lon) limits and spacing followed by the data section like: lat1 lat2 lon1 lon2 dlat dlon dn1 dn2 ... dnm ... ... d11 d12 ... d1m The grid label defines the exact latitude and longitude of the grid points with: lat1: west boundary of latitude lat2: east boundary of latitude lon1: west boundary of longitude lon2: east boundary of longitude dlat: latitude grid spacing dlon: longitude grid spacing The first data value in a grid file is thus the NW-corner (lat2, lon1) and the last the SE-corner (lat1, lon2). The number of points in a grid file is thus: num_lat = (lat2 - lat1)/dlat + 1 num_lon = (lon2 - lon1)/dlon + 1 Unknown data are shown by 9999. More information about the GRAVSOFT grid format can be found under: Forsberg, R. and Tscherning, C. C. (2014): \"An overview manual for the GRAVSOFT Geodetic Gravity Field Modelling Programs\", 3. edition, August 2014 Example: from midgard import parsers p = parsers.parse_file(parser_name=\"gravsoft_grid\", file_path=\"MeanSeaLevel1996-2014_above_Ellipsoid_EUREF89_v2021a.bin\") data = p.as_dict()","title":"midgard.parsers.gravsoft_grid"},{"location":"api/midgard-parsers/#gravsoftgrid","text":"Full name: midgard.parsers.gravsoft_grid.GravsoftGrid Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading GRAVSOFT grid text files Following data are available after reading data: Parameter Description griddata Grid data with ordered grid blocks as list and meta -data: Key Description grid_increment_lat Latitude grid increment in degree grid_increment_lon Longitude grid increment in degree grid_lat_max Maximal latitude border limit of grid area in degree grid_lat_max Maximal latitude border limit of grid area in degree grid_lat_min Minimal latitude border limit of grid area in degree grid_lon_max Maximal longitude border limit of grid area in degree grid_lon_min Minimal longitude border limit of grid area in degree data_path File path parser_name Parser name","title":"GravsoftGrid"},{"location":"api/midgard-parsers/#midgardparsersrinex212_nav","text":"A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex212_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.12 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.12. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ).","title":"midgard.parsers.rinex212_nav"},{"location":"api/midgard-parsers/#rinex212navparser","text":"Full name: midgard.parsers.rinex212_nav.Rinex212NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.12 (see :cite: rinex2 ).","title":"Rinex212NavParser"},{"location":"api/midgard-parsers/#todo-would-it-not-be-better-to-use-one-leading-underscore-for-non-public-methods-and-instance-variables","text":"Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale","title":"TODO: Would it not be better to use one leading underscore for non-public methods and instance variables."},{"location":"api/midgard-parsers/#sysnames-dict","text":"SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}}","title":"SYSNAMES (dict)"},{"location":"api/midgard-parsers/#system_file_extension-dict","text":"SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'}","title":"SYSTEM_FILE_EXTENSION (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_second-dict","text":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_week-dict","text":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex2_nav","text":"A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.11 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.11. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ).","title":"midgard.parsers.rinex2_nav"},{"location":"api/midgard-parsers/#rinex2navparser","text":"Full name: midgard.parsers.rinex2_nav.Rinex2NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.11 (see :cite: rinex2 ).","title":"Rinex2NavParser"},{"location":"api/midgard-parsers/#todo-would-it-not-be-better-to-use-one-leading-underscore-for-non-public-methods-and-instance-variables_1","text":"Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ion_alpha() Parse entries of RINEX header `ION ALPHA` to instance variable `meta`. _parse_ion_beta() Parse entries of RINEX header `ION BETA` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `DELTA-UTC: A0,A1,T,W` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale","title":"TODO: Would it not be better to use one leading underscore for non-public methods and instance variables."},{"location":"api/midgard-parsers/#sysnames-dict_1","text":"SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}}","title":"SYSNAMES (dict)"},{"location":"api/midgard-parsers/#system_file_extension-dict_1","text":"SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'}","title":"SYSTEM_FILE_EXTENSION (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_second-dict_1","text":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_week-dict_1","text":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex2_obs","text":"A parser for reading Rinex data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the Rinex file format 2.11 (see :cite: rinex2 ).","title":"midgard.parsers.rinex2_obs"},{"location":"api/midgard-parsers/#rinex2parser","text":"Full name: midgard.parsers.rinex2_obs.Rinex2Parser Signature: (*args: Tuple[Any], sampling_rate: Optional[float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 2.11 (see :cite: rinex2 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. system (String): GNSS identifier. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition.","title":"Rinex2Parser"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_time-dict","text":"SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex3_nav","text":"A parser for reading GNSS RINEX v3.03 navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 3.03 (see :cite: rinex3 ). An exception is also, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale.","title":"midgard.parsers.rinex3_nav"},{"location":"api/midgard-parsers/#rinex3navparser","text":"Full name: midgard.parsers.rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 3.03 (see :cite: rinex3 ) except for GLONASS and SBAS.","title":"Rinex3NavParser"},{"location":"api/midgard-parsers/#todo-would-it-not-be-better-to-use-one-leading-underscore-for-non-public-methods-and-instance-variables_2","text":"Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale","title":"TODO: Would it not be better to use one leading underscore for non-public methods and instance variables."},{"location":"api/midgard-parsers/#sysnames-dict_2","text":"SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}}","title":"SYSNAMES (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_second-dict_2","text":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'G': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_week-dict_2","text":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'G': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex3_obs","text":"A parser for reading RINEX format 3.03 data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the RINEX file format version 3.03 (see :cite: rinex3 ).","title":"midgard.parsers.rinex3_obs"},{"location":"api/midgard-parsers/#rinex3parser","text":"Full name: midgard.parsers.rinex3_obs.Rinex3Parser Signature: (*args: Tuple[Any], sampling_rate: Optional[float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 3.03 (see :cite: rinex3 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition. system (String): GNSS identifier.","title":"Rinex3Parser"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_time-dict_1","text":"SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex_nav","text":"A parser for reading GNSS RINEX navigation files Example: from midgard.data import dataset from midgard import parsers # Parse data parser = parsers.parse(file_path=file_path) # Create a empty Dataset dset = data.Dataset() # Fill Dataset with parsed data parser.write_to_dataset(dset) Description: Reads GNSS ephemeris data from RINEX navigation file in format 2.11 (see :cite: rinex2 ) or 3.03 (see :cite: rinex3 ).","title":"midgard.parsers.rinex_nav"},{"location":"api/midgard-parsers/#get_rinex2_or_rinex3","text":"Full name: midgard.parsers.rinex_nav.get_rinex2_or_rinex3 Signature: (file_path: pathlib.PosixPath) -> 'TODO' Use either Rinex2NavParser or Rinex3NavParser for reading orbit files in format 2.11 or 3.03. Firstly the RINEX file version is read. Based on the read version number it is decided, which Parser should be used. Args: file_path (pathlib.PosixPath): File path to broadcast orbit file.","title":"get_rinex2_or_rinex3()"},{"location":"api/midgard-parsers/#midgardparserssinex_discontinuities","text":"A parser for reading data from discontinuities.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='discontinuities_snx', file_path='discontinuities_snx') data = p.as_dict() Description: Reads discontinuities of GNSS station timeseries in SINEX format .","title":"midgard.parsers.sinex_discontinuities"},{"location":"api/midgard-parsers/#discontinuitiessnxparser","text":"Full name: midgard.parsers.sinex_discontinuities.DiscontinuitiesSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None A parser for reading data from discontinuties.snx file in SINEX format The solution discontinuity dictionary has as keys the site identifiers and as value the 'solution_discontinuity' entry. The dictionary has following strucuture: self.data[site] = { 'solution_discontinuity': [] } # SOLUTION/DISCONTINUITY SINEX block information with the 'solution_discontinuity' dictionary entries solution_discontinuity[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many discontinuities exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"DiscontinuitiesSnxParser"},{"location":"api/midgard-parsers/#midgardparserssinex_events","text":"A parser for reading data from events.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='events_snx', file_path='events_snx') data = p.as_dict() Description: Reads events related to GNSS configuration, environment changes or station timeseries data problems in SINEX format .","title":"midgard.parsers.sinex_events"},{"location":"api/midgard-parsers/#eventssnxparser","text":"Full name: midgard.parsers.sinex_events.EventsSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None A parser for reading data from events.snx file in SINEX format The solution events dictionary has as keys the site identifiers and as value the 'solution_event' entry. The dictionary has following strucuture: self.data[site] = { 'solution_event': [] } # SOLUTION/EVENT SINEX block information with the 'solution_event' dictionary entries solution_event[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many events exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"EventsSnxParser"},{"location":"api/midgard-parsers/#midgardparserssinex_site","text":"A parser for reading site related information from SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='sinex_site', file_path='sinex_site') data = p.as_dict() Description: Reads station related information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) from files in SINEX format. Following blocks are read: FILE/COMMENT SITE/ID SITE/RECEIVER SITE/ANTENNA SITE/ECCENTRICITY SOLUTION/EPOCHS SOLUTION/ESTIMATE Note, that FILE/COMMENT block is only used for reading reference frame information ('ref_frame'), which is added to SOLUTION/ESTIMATE dictionary.","title":"midgard.parsers.sinex_site"},{"location":"api/midgard-parsers/#sinexsiteparser","text":"Full name: midgard.parsers.sinex_site.SinexSiteParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, header: bool = True) -> None A parser for reading site related information from SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id', 'site_receiver', 'solution_epoch' and 'solution_estimate'. The site dictionary has following structure: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information 'solution_epoch': [], # SOLUTION/EPOCH block information 'solution_estimate': [], # SOLUTION/ESTIMATE block information } with the site entry dictionary entries site_antenna[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'site_code': site_code, 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } solution_epochs[ii] = { 'site_code': site_code, 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_epoch': start_epoch, 'end_epoch': end_epoch, 'mean_epoch': mean_epoch } solution_estimate[ii] = { 'param_idx': param_idx, 'param_name': param_name, 'point_code': point_code, 'site_code': site_code, 'soln': soln, 'ref_epoch': ref_epoch, 'unit': unit, 'constraint': constraint, 'estimate': estimate, 'estimate_std': estimate_std, 'ref_frame': ref_frame } # Note: ref_frame taken from # FILE/COMMENT block, if exists. The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type, antenna monument and station coordinate changes were done at each site. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"SinexSiteParser"},{"location":"api/midgard-parsers/#midgardparserssinex_tro","text":"A parser for reading troposphere results in SNX format Description: The implementation is based on example output files from Bernese. The SINEX_TRO format is an extension of the regular SINEX format, but mostly uses custom blocks. The following blocks are found in the example file: +FILE/REFERENCE (defined in SINEX 2.02) +TROP/DESCRIPTION (custom block) +TROP/STA_COORDINATES (custom block) +TROP/SOLUTION (custom block) The format of the custom blocks are derived by reading example files and blocks defined in the format that is not present in the example files are not implemented yet. Format description: https://files.igs.org/pub/data/format/sinex_tropo.txt","title":"midgard.parsers.sinex_tro"},{"location":"api/midgard-parsers/#berntropsnxparser","text":"Full name: midgard.parsers.sinex_tro.BernTropSnxParser Signature: (file_path, encoding=None) A parser for reading data from Bernese troposphere files in SNX format","title":"BernTropSnxParser"},{"location":"api/midgard-parsers/#midgardparsersslr_prediction","text":"A parser for reading SLR prediction files Description: Reads data from files in the CPF file format as defined in http://ilrs.gsfc.nasa.gov/docs/2006/cpf_1.01.pdf","title":"midgard.parsers.slr_prediction"},{"location":"api/midgard-parsers/#slrpredictionparser","text":"Full name: midgard.parsers.slr_prediction.SlrPredictionParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading SLR prediction files (CPF format)","title":"SlrPredictionParser"},{"location":"api/midgard-parsers/#midgardparsersspring_csv","text":"A parser for reading Spring CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='spring_csv', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in Spring CSV output format. The header information of the Spring CSV file is not read (TODO).","title":"midgard.parsers.spring_csv"},{"location":"api/midgard-parsers/#springcsvparser","text":"Full name: midgard.parsers.spring_csv.SpringCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Spring CSV output files The Spring CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the Spring CSV colum values. Depending on the Spring CSV following dataset fields can be available: Field Description acquiredsat Number of acquired satellites (TODO?) gdop Geometric dilution of precision hdop Horizontal dilution of precision pdop Position (3D) dilution of precision satinview Number of satellites in view system GNSS identifier based on RINEX definition (e.g. G: GPS, E: Galileo) tdop Time dilution of precision time Observation time given as Time object usedsat Number of used satellites vdop Vertical dilution of precision ... ...","title":"SpringCsvParser"},{"location":"api/midgard-parsers/#midgardparsersssc_site","text":"A parser for reading data from TRF files in SSC format Example: from midgard import parsers p = parsers.parse_file(parser_name='ssc_site', file_path='ssc_site') data = p.as_dict() Description: Reads station positions and velocities from TRF files in SSC format. The velocity model is a simple linear offset based on the reference epoch.","title":"midgard.parsers.ssc_site"},{"location":"api/midgard-parsers/#sscsiteparser","text":"Full name: midgard.parsers.ssc_site.SscSiteParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading data from TRF files in SSC format","title":"SscSiteParser"},{"location":"api/midgard-parsers/#midgardparsersterrapos_position","text":"A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format.","title":"midgard.parsers.terrapos_position"},{"location":"api/midgard-parsers/#terrapospositionparser","text":"Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (*args: Tuple[Any], station: Optional[str] = None, **kwargs: Dict[Any, Any]) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposPositionParser"},{"location":"api/midgard-parsers/#midgardparsersterrapos_residual","text":"A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format.","title":"midgard.parsers.terrapos_residual"},{"location":"api/midgard-parsers/#terraposresidualparser","text":"Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposResidualParser"},{"location":"api/midgard-parsers/#midgardparsersure_control_tool_csv","text":"A parser for reading URE Control Tool CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='ure_control_tool_csv', file_path='G_GAL258_E1E5a_URE-AllPRN_190301.csv') data = p.as_dict() Description: Reads data from files in URE Control Tool CSV output format. The header information of the URE Control Tool CSV file is not read (TODO).","title":"midgard.parsers.ure_control_tool_csv"},{"location":"api/midgard-parsers/#urecontroltoolcsvparser","text":"Full name: midgard.parsers.ure_control_tool_csv.UreControlToolCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading URE Control Tool CSV output files The URE Control Tool CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the URE Control Tool CSV colum values.","title":"UreControlToolCsvParser"},{"location":"api/midgard-parsers/#midgardparsersvlbi_source_names","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.vlbi_source_names"},{"location":"api/midgard-parsers/#vlbisourcenamesparser","text":"Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"VlbiSourceNamesParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex","text":"A parser for reading Rinex files","title":"midgard.parsers.wip_rinex"},{"location":"api/midgard-parsers/#rinex","text":"Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type","title":"rinex()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_nav","text":"A parser for reading RINEX navigation files with version 2.xx","title":"midgard.parsers.wip_rinex2_nav"},{"location":"api/midgard-parsers/#rinex2navparser_1","text":"Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 2.xx","title":"Rinex2NavParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_nav_header","text":"RINEX navigation header classes for file format version 2.xx","title":"midgard.parsers.wip_rinex2_nav_header"},{"location":"api/midgard-parsers/#rinex2navheadermixin","text":"Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex2navheaderparser","text":"Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex2NavHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_obs","text":"A parser for reading RINEX observation files with version 2.xx","title":"midgard.parsers.wip_rinex2_obs"},{"location":"api/midgard-parsers/#rinex2obsparser","text":"Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 2.xx","title":"Rinex2ObsParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex2_obs_header"},{"location":"api/midgard-parsers/#rinex2obsheadermixin","text":"Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex2obsheaderparser","text":"Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed.","title":"Rinex2ObsHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_clk","text":"A parser for reading RINEX clock files with version 3.xx","title":"midgard.parsers.wip_rinex3_clk"},{"location":"api/midgard-parsers/#rinex3clkparser","text":"Full name: midgard.parsers.wip_rinex3_clk.Rinex3ClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX clock files with version 3.xx","title":"Rinex3ClkParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_clk_header","text":"RINEX clock header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex3_clk_header"},{"location":"api/midgard-parsers/#rinex3clkheadermixin","text":"Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ClkHeaderMixin"},{"location":"api/midgard-parsers/#rinex3clkheaderparser","text":"Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed.","title":"Rinex3ClkHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_nav","text":"A parser for reading RINEX navigation files with version 3.xx","title":"midgard.parsers.wip_rinex3_nav"},{"location":"api/midgard-parsers/#rinex3navparser_1","text":"Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 3.xx","title":"Rinex3NavParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_nav_header","text":"RINEX navigation header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex3_nav_header"},{"location":"api/midgard-parsers/#rinex3navheadermixin","text":"Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex3navheaderparser","text":"Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex3NavHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_obs","text":"A parser for reading RINEX observation files with version 3.xx","title":"midgard.parsers.wip_rinex3_obs"},{"location":"api/midgard-parsers/#rinex3obsparser","text":"Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 3.xx","title":"Rinex3ObsParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex3_obs_header"},{"location":"api/midgard-parsers/#rinex3obsheadermixin","text":"Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex3obsheaderparser","text":"Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed.","title":"Rinex3ObsHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_clk","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_clk"},{"location":"api/midgard-parsers/#rinexclkparser","text":"Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None Class for defining common methods for RINEX clock parsers.","title":"RinexClkParser"},{"location":"api/midgard-parsers/#rinex_clk","text":"Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_clk()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_nav","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_nav"},{"location":"api/midgard-parsers/#rinexnavparser","text":"Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None Class for defining common methods for RINEX navigation parsers.","title":"RinexNavParser"},{"location":"api/midgard-parsers/#rinex_nav","text":"Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_nav()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_obs","text":"A parser for reading Rinex observation files","title":"midgard.parsers.wip_rinex_obs"},{"location":"api/midgard-parsers/#rinexobsparser","text":"Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Optional[str] = None, logger=<built-in function print>, sampling_rate: Optional[int] = None, strict: bool = False) -> None Class for defining common methods for RINEX observation parsers.","title":"RinexObsParser"},{"location":"api/midgard-parsers/#rinex_obs","text":"Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_obs()"},{"location":"api/midgard-plot/","text":"midgard.plot midgard.plot.matplotext Matplotlib extension class Description: Wrapper functions around matplotlib subroutines are defined in this class. MatPlotExt Full name: midgard.plot.matplotext.MatPlotExt Signature: (options: Dict[str, Any] = None) -> None Class for plotting - Extension of matplotlib Following options * can be selected: Option Value Description bar_text <True False> bar_text_offset Define text offset for text of bar plots bar_zeroline <True False> colorbar <True False> colorbar_label Color bar label colormap Color map type for plotting either events or labels (e.g. viridis, jet, tab10, rainbow, hsv, plasma) dpi Resolution of file in dots per inch ecapsize Cap size of error bar ecapthick Cap thick of error bar ecolor Color of error bar edgecolor Edge color of bars of bar plots elinewidth Line width of error bar errorbar <True False> figsize (num, num) Figure size given by (width, height) in inches fontsize Fontsize of title, axis labels and legend fsize_subtitle Fontsize of subplot title (statistical information) grid <True False> histogram Plot x-axis histogram on top, y-axis histogram on right or for both axis on scatter plot histogram_binwidth Histogram bin width histogram_size Histogram y-axis size legend <True False> legend_location Legend location legend_ncol The number of legend columns linestyle","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplot","text":"","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplotmatplotext","text":"Matplotlib extension class Description: Wrapper functions around matplotlib subroutines are defined in this class.","title":"midgard.plot.matplotext"},{"location":"api/midgard-plot/#matplotext","text":"Full name: midgard.plot.matplotext.MatPlotExt Signature: (options: Dict[str, Any] = None) -> None Class for plotting - Extension of matplotlib Following options * can be selected: Option Value Description bar_text <True False> bar_text_offset Define text offset for text of bar plots bar_zeroline <True False> colorbar <True False> colorbar_label Color bar label colormap Color map type for plotting either events or labels (e.g. viridis, jet, tab10, rainbow, hsv, plasma) dpi Resolution of file in dots per inch ecapsize Cap size of error bar ecapthick Cap thick of error bar ecolor Color of error bar edgecolor Edge color of bars of bar plots elinewidth Line width of error bar errorbar <True False> figsize (num, num) Figure size given by (width, height) in inches fontsize Fontsize of title, axis labels and legend fsize_subtitle Fontsize of subplot title (statistical information) grid <True False> histogram Plot x-axis histogram on top, y-axis histogram on right or for both axis on scatter plot histogram_binwidth Histogram bin width histogram_size Histogram y-axis size legend <True False> legend_location Legend location legend_ncol The number of legend columns linestyle","title":"MatPlotExt"},{"location":"api/midgard-site_info/","text":"midgard.site_info midgard.site_info._site_info Base classes for site information. Description: All the base classes are abstract classes. There are three base classes defined. TODO: 'Identifier' module has no history information. ModuleBase and SiteInfoBase class are adapted to that. The question is should it be handled differently. E.g. ModuleBase.get_history() function is not needed from 'Identifier' module, but is available. ModuleBase Full name: midgard.site_info._site_info.ModuleBase Signature: () Base class for each module of site information (e.g. Antenna, Receiver, ...). Allows different sources of site information history to be registered. SiteInfoBase Full name: midgard.site_info._site_info.SiteInfoBase Signature: (station: str, site_info: Dict[str, Any]) -> None Site information base class defining common attributes and methods SiteInfoHistoryBase Full name: midgard.site_info._site_info.SiteInfoHistoryBase Signature: (station: str, source_data: Any = None, source_path: str = None) -> None Base class defining common attributes and methods for history classes SiteInfoHistoryIterator Full name: midgard.site_info._site_info.SiteInfoHistoryIterator Signature: (site_info_history) Iterator class for SiteInfoHistory classes midgard.site_info.antenna Antenna information classes Description: This module is divided into three different types of classes: 1. Main class Antenna provides basic functionality to the user. See exampless 2. Antenna source type classes: - There is one class for each source type. - A class with all relevant antenna information for a point in time. 3. Antenna history source type classes: - There is one class for each source type. - Converts input from source_data to a object of type AntennaHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of an antenna source type class for each defined time interval. If a source type does not contain information about the antenna the module will return 'None'. Example: from midgard import parsers from midgard.site_info.antenna import Antenna from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Antenna.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Antenna.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Antenna.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) Antenna.get_history(\"snx\", all_stations, source_data, source_path=p.file_path) Antenna Full name: midgard.site_info.antenna.Antenna Signature: () Main class for converting antenna information from various sources into unified classes AntennaHistorySinex Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None AntennaHistorySsc Full name: midgard.site_info.antenna.AntennaHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None AntennaSinex Full name: midgard.site_info.antenna.AntennaSinex Signature: (station: str, site_info: Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information midgard.site_info.eccentricity Eccentricity information classes Description: This module is divided into three different types of classes: 1. Main class Eccentricity provides basic functionality to the user. See examples. 2. Eccentricity source type classes: - There is one class for each source type - A class with all relevant site coordinate information for a point in time. 3. Eccentricity history source type classes: - There is one class for each source type - Converts input from source_data to a object of type EccentricityHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of an eccentricity source type class for each defined time interval. If a source type does not contain information about the eccentricity the module will return 'None'. Example: from midgard import parsers from midgard.site_info.eccentricity import Eccentricity from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Eccentricity.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Eccentricity.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Eccentricity.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) Eccentricity.get_history(\"snx\", all_stations, source_data, source_path=p.file_path) Eccentricity Full name: midgard.site_info.eccentricity.Eccentricity Signature: () Main class for converting eccentricity information from various sources into unified classes EccentricityHistorySinex Full name: midgard.site_info.eccentricity.EccentricityHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None EccentricityHistorySsc Full name: midgard.site_info.eccentricity.EccentricityHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None EccentricitySinex Full name: midgard.site_info.eccentricity.EccentricitySinex Signature: (station: str, site_info: Dict[str, Any]) -> None Eccentricity class handling SINEX file eccentricity station information midgard.site_info.identifier Identifier information classes Description: This module is divided into three different types of classes: 1. Main class Identifier provides basic functionality to the user. See examples. 2. Identifier source type classes: - There is one class for each source type - A class with all relevant site coordinate information for a point in time. If a source type does not contain information about the identifier the module will return 'None'. Example: from midgard import parsers from midgard.site_info.identifier import Identifier from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Identifier.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Identifier.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Identifier Full name: midgard.site_info.identifier.Identifier Signature: () Main class for converting identifier information from various sources into unified classes IdentifierSinex Full name: midgard.site_info.identifier.IdentifierSinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None Identifier class handling SINEX file identifier station information IdentifierSsc Full name: midgard.site_info.identifier.IdentifierSsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None Identifier class handling SSC file identifier station information midgard.site_info.receiver Receiver information classes Description: This module is divided into three different types of classes: 1. Main class Receiver provides basic functionality to the user. See examples. 2. Receiver source type classes: - There is one class for each source type - A class with all relevant receiver information for a point in time. 3. Receiver history source type classes: - There is one class for each source type - Converts input from source_data to a object of type ReceiverHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of a receiver source type class for each defined time interval. If a source type does not contain information about the receiver the module will return 'None'. Example: from midgard import parsers from midgard.site_info.receiver import Receiver from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Receiver.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Receiver.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Receiver.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) Receiver.get_history(\"snx\", all_stations, source_data, source_path=p.file_path) Receiver Full name: midgard.site_info.receiver.Receiver Signature: () Main class for converting receiver information from various sources into unified classes ReceiverHistorySinex Full name: midgard.site_info.receiver.ReceiverHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None ReceiverHistorySsc Full name: midgard.site_info.receiver.ReceiverHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None ReceiverSinex Full name: midgard.site_info.receiver.ReceiverSinex Signature: (station: str, site_info: Dict[str, Any]) -> None Receiver class handling SINEX file receiver station information midgard.site_info.site_coord Site cooridnate information classes Description: This module is divided into three different types of classes: 1. Main class SiteCoord provides basic functionality to the user. See exampless 2. Site coordinate source type classes: - There is one class for each source type. - A class with all relevant site coordinate information for a point in time. 3. Site coordinate history source type classes: - There is one class for each source type. - Converts input from source_data to a object of type SiteCoordHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of a site coordinate source type class for each defined time interval. If a source type does not contain information about the site coordinates the module will return 'None'. Example: from midgard import parsers from midgard.site_info.site_coord import SiteCoord from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information SiteCoord.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteCoord.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteCoord.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) SiteCoord.get_history(\"snx\", all_stations, source_data, source_path=p.file_path) SiteCoord Full name: midgard.site_info.site_coord.SiteCoord Signature: () Main class for converting site coordinates from various sources into unified classes SiteCoordHistorySinex Full name: midgard.site_info.site_coord.SiteCoordHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None SiteCoordHistorySsc Full name: midgard.site_info.site_coord.SiteCoordHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None SiteCoordSinex Full name: midgard.site_info.site_coord.SiteCoordSinex Signature: (station: str, site_info: Dict[str, Any]) -> None Site coordinate class handling SINEX file station coordinate information SiteCoordSsc Full name: midgard.site_info.site_coord.SiteCoordSsc Signature: (station: str, site_info: Dict[str, Any]) -> None Site coordinate class handling SSC file station coordinate information midgard.site_info.site_info Module that provides site information as unified objects independent of source. Description: Site information consists of antenna, eccentricity and receiver information and coordinates for a station. If a source type does not contain information about the antenna, receiver or coordinate the corresponding entry will be set to 'None'. Example: from midgard import parsers from midgard.site_info.site_info import SiteInfo from datetime import datetime p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() SiteInfo.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteInfo.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteInfo.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) SiteInfo.get_history(\"snx\", all_stations, source_data, source_path=p.file_path) Description: SiteInfo Full name: midgard.site_info.site_info.SiteInfo Signature: () Main site information class for site information from various sources into unified classes","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_info","text":"","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_info_site_info","text":"Base classes for site information. Description: All the base classes are abstract classes. There are three base classes defined. TODO: 'Identifier' module has no history information. ModuleBase and SiteInfoBase class are adapted to that. The question is should it be handled differently. E.g. ModuleBase.get_history() function is not needed from 'Identifier' module, but is available.","title":"midgard.site_info._site_info"},{"location":"api/midgard-site_info/#modulebase","text":"Full name: midgard.site_info._site_info.ModuleBase Signature: () Base class for each module of site information (e.g. Antenna, Receiver, ...). Allows different sources of site information history to be registered.","title":"ModuleBase"},{"location":"api/midgard-site_info/#siteinfobase","text":"Full name: midgard.site_info._site_info.SiteInfoBase Signature: (station: str, site_info: Dict[str, Any]) -> None Site information base class defining common attributes and methods","title":"SiteInfoBase"},{"location":"api/midgard-site_info/#siteinfohistorybase","text":"Full name: midgard.site_info._site_info.SiteInfoHistoryBase Signature: (station: str, source_data: Any = None, source_path: str = None) -> None Base class defining common attributes and methods for history classes","title":"SiteInfoHistoryBase"},{"location":"api/midgard-site_info/#siteinfohistoryiterator","text":"Full name: midgard.site_info._site_info.SiteInfoHistoryIterator Signature: (site_info_history) Iterator class for SiteInfoHistory classes","title":"SiteInfoHistoryIterator"},{"location":"api/midgard-site_info/#midgardsite_infoantenna","text":"Antenna information classes Description: This module is divided into three different types of classes: 1. Main class Antenna provides basic functionality to the user. See exampless 2. Antenna source type classes: - There is one class for each source type. - A class with all relevant antenna information for a point in time. 3. Antenna history source type classes: - There is one class for each source type. - Converts input from source_data to a object of type AntennaHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of an antenna source type class for each defined time interval. If a source type does not contain information about the antenna the module will return 'None'. Example: from midgard import parsers from midgard.site_info.antenna import Antenna from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Antenna.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Antenna.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Antenna.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) Antenna.get_history(\"snx\", all_stations, source_data, source_path=p.file_path)","title":"midgard.site_info.antenna"},{"location":"api/midgard-site_info/#antenna","text":"Full name: midgard.site_info.antenna.Antenna Signature: () Main class for converting antenna information from various sources into unified classes","title":"Antenna"},{"location":"api/midgard-site_info/#antennahistorysinex","text":"Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"AntennaHistorySinex"},{"location":"api/midgard-site_info/#antennahistoryssc","text":"Full name: midgard.site_info.antenna.AntennaHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"AntennaHistorySsc"},{"location":"api/midgard-site_info/#antennasinex","text":"Full name: midgard.site_info.antenna.AntennaSinex Signature: (station: str, site_info: Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information","title":"AntennaSinex"},{"location":"api/midgard-site_info/#midgardsite_infoeccentricity","text":"Eccentricity information classes Description: This module is divided into three different types of classes: 1. Main class Eccentricity provides basic functionality to the user. See examples. 2. Eccentricity source type classes: - There is one class for each source type - A class with all relevant site coordinate information for a point in time. 3. Eccentricity history source type classes: - There is one class for each source type - Converts input from source_data to a object of type EccentricityHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of an eccentricity source type class for each defined time interval. If a source type does not contain information about the eccentricity the module will return 'None'. Example: from midgard import parsers from midgard.site_info.eccentricity import Eccentricity from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Eccentricity.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Eccentricity.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Eccentricity.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) Eccentricity.get_history(\"snx\", all_stations, source_data, source_path=p.file_path)","title":"midgard.site_info.eccentricity"},{"location":"api/midgard-site_info/#eccentricity","text":"Full name: midgard.site_info.eccentricity.Eccentricity Signature: () Main class for converting eccentricity information from various sources into unified classes","title":"Eccentricity"},{"location":"api/midgard-site_info/#eccentricityhistorysinex","text":"Full name: midgard.site_info.eccentricity.EccentricityHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"EccentricityHistorySinex"},{"location":"api/midgard-site_info/#eccentricityhistoryssc","text":"Full name: midgard.site_info.eccentricity.EccentricityHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"EccentricityHistorySsc"},{"location":"api/midgard-site_info/#eccentricitysinex","text":"Full name: midgard.site_info.eccentricity.EccentricitySinex Signature: (station: str, site_info: Dict[str, Any]) -> None Eccentricity class handling SINEX file eccentricity station information","title":"EccentricitySinex"},{"location":"api/midgard-site_info/#midgardsite_infoidentifier","text":"Identifier information classes Description: This module is divided into three different types of classes: 1. Main class Identifier provides basic functionality to the user. See examples. 2. Identifier source type classes: - There is one class for each source type - A class with all relevant site coordinate information for a point in time. If a source type does not contain information about the identifier the module will return 'None'. Example: from midgard import parsers from midgard.site_info.identifier import Identifier from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Identifier.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Identifier.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path)","title":"midgard.site_info.identifier"},{"location":"api/midgard-site_info/#identifier","text":"Full name: midgard.site_info.identifier.Identifier Signature: () Main class for converting identifier information from various sources into unified classes","title":"Identifier"},{"location":"api/midgard-site_info/#identifiersinex","text":"Full name: midgard.site_info.identifier.IdentifierSinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None Identifier class handling SINEX file identifier station information","title":"IdentifierSinex"},{"location":"api/midgard-site_info/#identifierssc","text":"Full name: midgard.site_info.identifier.IdentifierSsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None Identifier class handling SSC file identifier station information","title":"IdentifierSsc"},{"location":"api/midgard-site_info/#midgardsite_inforeceiver","text":"Receiver information classes Description: This module is divided into three different types of classes: 1. Main class Receiver provides basic functionality to the user. See examples. 2. Receiver source type classes: - There is one class for each source type - A class with all relevant receiver information for a point in time. 3. Receiver history source type classes: - There is one class for each source type - Converts input from source_data to a object of type ReceiverHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of a receiver source type class for each defined time interval. If a source type does not contain information about the receiver the module will return 'None'. Example: from midgard import parsers from midgard.site_info.receiver import Receiver from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information Receiver.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) Receiver.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) Receiver.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) Receiver.get_history(\"snx\", all_stations, source_data, source_path=p.file_path)","title":"midgard.site_info.receiver"},{"location":"api/midgard-site_info/#receiver","text":"Full name: midgard.site_info.receiver.Receiver Signature: () Main class for converting receiver information from various sources into unified classes","title":"Receiver"},{"location":"api/midgard-site_info/#receiverhistorysinex","text":"Full name: midgard.site_info.receiver.ReceiverHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"ReceiverHistorySinex"},{"location":"api/midgard-site_info/#receiverhistoryssc","text":"Full name: midgard.site_info.receiver.ReceiverHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"ReceiverHistorySsc"},{"location":"api/midgard-site_info/#receiversinex","text":"Full name: midgard.site_info.receiver.ReceiverSinex Signature: (station: str, site_info: Dict[str, Any]) -> None Receiver class handling SINEX file receiver station information","title":"ReceiverSinex"},{"location":"api/midgard-site_info/#midgardsite_infosite_coord","text":"Site cooridnate information classes Description: This module is divided into three different types of classes: 1. Main class SiteCoord provides basic functionality to the user. See exampless 2. Site coordinate source type classes: - There is one class for each source type. - A class with all relevant site coordinate information for a point in time. 3. Site coordinate history source type classes: - There is one class for each source type. - Converts input from source_data to a object of type SiteCoordHistorySinex, etc and provides functions for accessing the history and relevant dates. - The history consist of a time interval for which the entry is valid and an instance of a site coordinate source type class for each defined time interval. If a source type does not contain information about the site coordinates the module will return 'None'. Example: from midgard import parsers from midgard.site_info.site_coord import SiteCoord from datetime import datetime # Read SINEX data p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() # Get station information SiteCoord.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteCoord.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteCoord.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) SiteCoord.get_history(\"snx\", all_stations, source_data, source_path=p.file_path)","title":"midgard.site_info.site_coord"},{"location":"api/midgard-site_info/#sitecoord","text":"Full name: midgard.site_info.site_coord.SiteCoord Signature: () Main class for converting site coordinates from various sources into unified classes","title":"SiteCoord"},{"location":"api/midgard-site_info/#sitecoordhistorysinex","text":"Full name: midgard.site_info.site_coord.SiteCoordHistorySinex Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"SiteCoordHistorySinex"},{"location":"api/midgard-site_info/#sitecoordhistoryssc","text":"Full name: midgard.site_info.site_coord.SiteCoordHistorySsc Signature: (station: str, source_data: Any = None, source_path: str = None) -> None","title":"SiteCoordHistorySsc"},{"location":"api/midgard-site_info/#sitecoordsinex","text":"Full name: midgard.site_info.site_coord.SiteCoordSinex Signature: (station: str, site_info: Dict[str, Any]) -> None Site coordinate class handling SINEX file station coordinate information","title":"SiteCoordSinex"},{"location":"api/midgard-site_info/#sitecoordssc","text":"Full name: midgard.site_info.site_coord.SiteCoordSsc Signature: (station: str, site_info: Dict[str, Any]) -> None Site coordinate class handling SSC file station coordinate information","title":"SiteCoordSsc"},{"location":"api/midgard-site_info/#midgardsite_infosite_info","text":"Module that provides site information as unified objects independent of source. Description: Site information consists of antenna, eccentricity and receiver information and coordinates for a station. If a source type does not contain information about the antenna, receiver or coordinate the corresponding entry will be set to 'None'. Example: from midgard import parsers from midgard.site_info.site_info import SiteInfo from datetime import datetime p = parsers.parse_file(parser_name='sinex_site', file_path='./data/site_info/igs.snx') source_data = p.as_dict() all_stations = source_data.keys() SiteInfo.get(\"snx\", \"osls\", datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteInfo.get(\"snx\", all_stations, datetime(2020, 1, 1), source_data, source_path=p.file_path) SiteInfo.get_history(\"snx\", \"osls\", source_data, source_path=p.file_path) SiteInfo.get_history(\"snx\", all_stations, source_data, source_path=p.file_path) Description:","title":"midgard.site_info.site_info"},{"location":"api/midgard-site_info/#siteinfo","text":"Full name: midgard.site_info.site_info.SiteInfo Signature: () Main site information class for site information from various sources into unified classes","title":"SiteInfo"},{"location":"api/midgard-writers/","text":"midgard.writers Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ... names () Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers. write () Full name: midgard.writers.write Signature: (writer: str, **writer_args: Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer. midgard.writers._writers Basic functionality for writing files Description: This module contains functions for writing files. get_existing_fields () Full name: midgard.writers._writers.get_existing_fields Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Writer fields. Returns: Existing writer fields get_existing_fields_by_attrs () Full name: midgard.writers._writers.get_existing_fields_by_attrs Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Fields to write/plot. Returns: Existing writer fields get_field () Full name: midgard.writers._writers.get_field Signature: (dset: 'Dataset', field: str, attrs: Tuple[str], unit: Optional[str] = None) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. field : Field name. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values get_field_by_attrs () Full name: midgard.writers._writers.get_field_by_attrs Signature: (dset: 'Dataset', attrs: Tuple[str], unit: str) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values get_header () Full name: midgard.writers._writers.get_header Signature: (fields: List[str], pgm_version: Optional[str] = None, run_by: str = '', summary: Optional[str] = None, add_description: Optional[str] = None, lsign: str = '') -> str Get header Args: fields : List with fields to write. pgm_version : Name and version (e.g. where 1.0.0) of program, which has created the output. run_by : Information about who has created this file (e.g. NMA). summary : Short description of output file add_description : Additional description lines lsign : Leading comment sign Returns: Header lines get_value_by_keys () Full name: midgard.writers._writers.get_value_by_keys Signature: (dict_: Dict[str, Any], keys: Tuple[str], format_=None, unit=None) -> Union[Any, List[Any]] Get value of a dictionary specified by keys If option format_ is defined, then formatted string is returned instead of original value. Args: dict_ : Dictionary with data keys : Dictionary keys format_ : Format definition unit : Unit definition in format 2 (e.g. meter2millimeter) Returns: Original dictionary value or string formatted value","title":"midgard.writers"},{"location":"api/midgard-writers/#midgardwriters","text":"Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ...","title":"midgard.writers"},{"location":"api/midgard-writers/#names","text":"Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers.","title":"names()"},{"location":"api/midgard-writers/#write","text":"Full name: midgard.writers.write Signature: (writer: str, **writer_args: Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer.","title":"write()"},{"location":"api/midgard-writers/#midgardwriters_writers","text":"Basic functionality for writing files Description: This module contains functions for writing files.","title":"midgard.writers._writers"},{"location":"api/midgard-writers/#get_existing_fields","text":"Full name: midgard.writers._writers.get_existing_fields Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Writer fields. Returns: Existing writer fields","title":"get_existing_fields()"},{"location":"api/midgard-writers/#get_existing_fields_by_attrs","text":"Full name: midgard.writers._writers.get_existing_fields_by_attrs Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Fields to write/plot. Returns: Existing writer fields","title":"get_existing_fields_by_attrs()"},{"location":"api/midgard-writers/#get_field","text":"Full name: midgard.writers._writers.get_field Signature: (dset: 'Dataset', field: str, attrs: Tuple[str], unit: Optional[str] = None) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. field : Field name. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values","title":"get_field()"},{"location":"api/midgard-writers/#get_field_by_attrs","text":"Full name: midgard.writers._writers.get_field_by_attrs Signature: (dset: 'Dataset', attrs: Tuple[str], unit: str) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values","title":"get_field_by_attrs()"},{"location":"api/midgard-writers/#get_header","text":"Full name: midgard.writers._writers.get_header Signature: (fields: List[str], pgm_version: Optional[str] = None, run_by: str = '', summary: Optional[str] = None, add_description: Optional[str] = None, lsign: str = '') -> str Get header Args: fields : List with fields to write. pgm_version : Name and version (e.g. where 1.0.0) of program, which has created the output. run_by : Information about who has created this file (e.g. NMA). summary : Short description of output file add_description : Additional description lines lsign : Leading comment sign Returns: Header lines","title":"get_header()"},{"location":"api/midgard-writers/#get_value_by_keys","text":"Full name: midgard.writers._writers.get_value_by_keys Signature: (dict_: Dict[str, Any], keys: Tuple[str], format_=None, unit=None) -> Union[Any, List[Any]] Get value of a dictionary specified by keys If option format_ is defined, then formatted string is returned instead of original value. Args: dict_ : Dictionary with data keys : Dictionary keys format_ : Format definition unit : Unit definition in format 2 (e.g. meter2millimeter) Returns: Original dictionary value or string formatted value","title":"get_value_by_keys()"},{"location":"api/midgard/","text":"midgard Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Midgard comes organized into different subpackages: writers dev math config collections plot site_info ionosphere data parsers files gnss Look for help inside each subpackage: >>> from midgard import subpackage # doctest: +SKIP >>> help(subpackage) # doctest: +SKIP Current maintainers: Michael D\u00e4hnn michael.daehnn@kartverket.no Ingrid Fausk ingrid.fausk@kartverket.no Ann-Silje Kirkvik ann-silje.kirkvik@kartverket.no Mohammed Ouassou mohammed.ouassou@kartverket.no Hans Sverre Smal\u00f8 hans.sverre.smalo@kartverket.no Geir Arne Hjelle geirarne@gmail.com","title":"midgard"},{"location":"howto/testing/","text":"Testing It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"},{"location":"howto/testing/#testing","text":"It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"}]}